{
    "sourceFile": "src/xyz/didx/didcomm/DIDCodec.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1696854481475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1696854487632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n import io.circe.Decoder.Result\n import io.circe.*\n \n import java.net.URI\n-import xyz.didx.didcomm..\n+import xyz.didx.didcomm.*\n import xyz.didx.didcomm.VerificationMethodType\n \n //import summon.{Decoder => _, _}\n \n"
                },
                {
                    "date": 1697444105400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,18 @@\n import cats.*\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n+given encodeService: Encoder[Service] = \n+  new Encoder[Service]:\n+    final def apply(a: Service): Json =\n+      Json.obj(\n+        (\"id\", Json.fromString(a.id.toString)),\n+        (\"type\", Json.fromString(a.`type`)),\n+        (\"serviceEndpoint\", Json.fromString(a.serviceEndpoint.toString)),\n+        (\"routingKeys\", Json.fromValues(a.routingKeys.map(r => Json.fromString(r.toString)))),\n+        (\"priority\", Json.fromInt(a.priority))\n+      )\n \n import java.net.URI\n import xyz.didx.didcomm.*\n import xyz.didx.didcomm.VerificationMethodType\n"
                },
                {
                    "date": 1697444113066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,19 +3,10 @@\n import cats.*\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n-given encodeService: Encoder[Service] = \n-  new Encoder[Service]:\n-    final def apply(a: Service): Json =\n-      Json.obj(\n-        (\"id\", Json.fromString(a.id.toString)),\n-        (\"type\", Json.fromString(a.`type`)),\n-        (\"serviceEndpoint\", Json.fromString(a.serviceEndpoint.toString)),\n-        (\"routingKeys\", Json.fromValues(a.routingKeys.map(r => Json.fromString(r.toString)))),\n-        (\"priority\", Json.fromInt(a.priority))\n-      )\n \n+\n import java.net.URI\n import xyz.didx.didcomm.*\n import xyz.didx.didcomm.VerificationMethodType\n \n"
                },
                {
                    "date": 1697444134787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n import cats.*\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n+sttp.tapir.generic.auto._\n \n \n import java.net.URI\n import xyz.didx.didcomm.*\n"
                },
                {
                    "date": 1697444140215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import cats.*\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n-sttp.tapir.generic.auto._\n+sttp.tapir.generic.auto.\n \n \n import java.net.URI\n import xyz.didx.didcomm.*\n"
                },
                {
                    "date": 1697444147745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import cats.*\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n-sttp.tapir.generic.auto.\n+import sttp.tapir.generic.auto.*\n \n \n import java.net.URI\n import xyz.didx.didcomm.*\n"
                },
                {
                    "date": 1697444252498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,12 @@\n import cats.syntax.all.*\n import io.circe.Decoder.Result\n import io.circe.*\n import sttp.tapir.generic.auto.*\n+import sttp.tapir.json.circe.*\n \n \n+\n import java.net.URI\n import xyz.didx.didcomm.*\n import xyz.didx.didcomm.VerificationMethodType\n \n"
                }
            ],
            "date": 1696854481475,
            "name": "Commit-0",
            "content": "package xyz.didx.didcomm\n\nimport cats.*\nimport cats.syntax.all.*\nimport io.circe.Decoder.Result\nimport io.circe.*\n\nimport java.net.URI\nimport xyz.didx.didcomm..\nimport xyz.didx.didcomm.VerificationMethodType\n\n//import summon.{Decoder => _, _}\n\nobject DIDCodec:\n  given encodeDIDDoc: Encoder[DIDDoc] =\n    new Encoder[DIDDoc]:\n      final def apply(a: DIDDoc): Json =\n        Json.obj(\n          (\n            \"didDocument\",\n            Json.obj(\n              (\"id\", Json.fromString(a.did)),\n              (\"controller\", Json.fromString(a.controller.getOrElse(\"\"))),\n              (\n                \"alsoKnownAs\",\n                Json.fromValues(\n                  a.alsoKnownAs.getOrElse(Set.empty).map(Json.fromString)\n                )\n              ),\n              (\n                \"verificationMethod\",\n                Json.fromValues(\n                  a.verificationMethods\n                    .getOrElse(Set.empty)\n                    .map(encodeVerificationMethod.apply)\n                )\n              ),\n              (\n                \"keyAgreement\",\n                Json.fromValues(\n                  a.keyAgreements\n                    .getOrElse(Set.empty)\n                    .map(encodeKeyAgreement.apply)\n                )\n              ),\n              (\n                \"authentication\",\n                Json.fromValues(\n                  a.authentications\n                    .getOrElse(Set.empty)\n                    .map(encodeAuthentication.apply)\n                )\n              ),\n              (\n                \"assertionMethod\",\n                Json.fromValues(\n                  a.assertionMethods\n                    .getOrElse(Set.empty)\n                    .map(encodeAssertion.apply)\n                )\n              ),\n              (\n                \"capabilityInvocation\",\n                Json.fromValues(\n                  a.capabilityInvocations\n                    .getOrElse(Set.empty)\n                    .map(encodeCapabilityInvocation.apply)\n                )\n              ),\n              (\n                \"capabilityDelegations\",\n                Json.fromValues(\n                  a.capabilityDelegations\n                    .getOrElse(Set.empty)\n                    .map(encodeCapabilityDelegation.apply)\n                )\n              ),\n              (\n                \"service\",\n                Json.fromValues(\n                  a.services.getOrElse(Set.empty).map(encodeService.apply)\n                )\n              )\n            )\n          )\n        )\n\n  given encodeVerificationMethod: Encoder[VerificationMethod] =\n    new Encoder[VerificationMethod]:\n      final def apply(a: VerificationMethod): Json =\n        Json.obj(\n          (\"id\", Json.fromString(a.id)),\n          (\"type\", Json.fromString(a.`type`.toString())),\n          (\"controller\", Json.fromString(a.controller)),\n          (\"public\", encodeVerificationMaterial.apply(a.verificationMaterial))\n        )\n\n  given encodeVerificationMaterial: Encoder[VerificationMaterial] =\n    new Encoder[VerificationMaterial]:\n      final def apply(a: VerificationMaterial): Json =\n        a match\n          case VerificationMaterialJWK(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case VerificationMaterialMultibase(value) =>\n            Json.fromString(value)\n\n  given encodeKeyAgreement: Encoder[KeyAgreement] =\n    new Encoder[KeyAgreement]:\n      final def apply(a: KeyAgreement): Json =\n        a match {\n          case KeyAgreementInstance(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case KeyAgreementReference(value) =>\n            Json.fromString(value)\n        }\n\n  given encoderKeyAgreementInstance: Encoder[KeyAgreementInstance] =\n    new Encoder[KeyAgreementInstance]:\n      final def apply(a: KeyAgreementInstance): Json =\n        Json.obj(\n          (\"id\", Json.fromString(a.id)),\n          (\"type\", Json.fromString(a.`type`)),\n          (\"controller\", Json.fromString(a.controller)),\n          (\"publicKeyMultibase\", Json.fromString(a.publicKeyMultibase))\n        )\n\n  given encodeAuthentication: Encoder[Authentication] =\n    new Encoder[Authentication]:\n      final def apply(a: Authentication): Json =\n        a match {\n          case AuthenticationInstance(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case AuthenticationReference(value) =>\n            Json.fromString(value)\n        }\n\n  given encodeAssertion: Encoder[Assertion] =\n    new Encoder[Assertion]:\n      final def apply(a: Assertion): Json =\n        a match {\n          case AssertionInstance(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case AssertionReference(value) =>\n            Json.fromString(value)\n        }\n\n  given encodeCapabilityInvocation: Encoder[CapabilityInvocation] =\n    new Encoder[CapabilityInvocation]:\n      final def apply(a: CapabilityInvocation): Json =\n        a match {\n          case CapabilityInvocationInstance(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case CapabilityInvocationReference(value) =>\n            Json.fromString(value)\n        }\n\n  given encodeCapabilityDelegation: Encoder[CapabilityDelegation] =\n    new Encoder[CapabilityDelegation]:\n      final def apply(a: CapabilityDelegation): Json =\n        a match {\n          case CapabilityDelegationInstance(crv, x, kty, kid) =>\n            Json.obj(\n              (\"crv\", Json.fromString(crv)),\n              (\"x\", Json.fromString(x)),\n              (\"kty\", Json.fromString(kty)),\n              (\"kid\", Json.fromString(kid))\n            )\n          case CapabilityDelegationReference(value) =>\n            Json.fromString(value)\n        }\n\n  given encodeURI: Encoder[URI] =\n    new Encoder[URI]:\n      final def apply(u: URI): Json = Json.fromString(u.toString)\n\n  given encodeService: Encoder[Service] =\n    new Encoder[Service]:\n      final def apply(a: Service): Json =\n        Json.obj(\n          (\"id\", Json.fromString(a.id.toString)),\n          (\n            \"type\",\n            Json.fromValues(a.`type`.map(_.toString).map(Json.fromString))\n          ),\n          (\n            \"serviceEndpoint\",\n            Json.fromValues(\n              a.serviceEndpoint.map(encodeDIDCommServiceEndpoint.apply)\n            )\n          )\n        )\n\n  given encodeDIDCommServiceEndpoint: Encoder[ServiceEndpoint] =\n    new Encoder[ServiceEndpoint]:\n      final def apply(a: ServiceEndpoint): Json =\n        a match {\n          case ServiceEndpointURI(value) => Json.fromString(value.toString)\n          case ServiceEndpointDIDURL(did, fragment) =>\n            Json.obj(\n              \"did\"      -> Json.fromString(did),\n              \"fragment\" -> Json.fromString(fragment)\n            )\n          case ServiceEndpointDIDCommService(uri, accept, routingKeys) =>\n            Json.obj(\n              \"uri\" -> Json.fromString(uri.toString),\n              \"accept\" -> Json.fromValues(\n                accept.map(_.toString).map(Json.fromString)\n              ),\n              \"routingKeys\" -> Json.fromValues(\n                routingKeys.map(_.toString).map(Json.fromString)\n              )\n            )\n          case ServiceEndpointNodes(nodes) =>\n            Json.obj(\n              \"nodes\" -> Json.fromValues(\n                nodes.map(n => n.toString).map(Json.fromString)\n              )\n            )\n        }\n\n  given decodeDIDDoc: Decoder[DIDDoc] =\n    new Decoder[DIDDoc]:\n      final def apply(cur: HCursor): Decoder.Result[DIDDoc] =\n        val c = cur.downField((\"didDocument\")).success match\n          case Some(c) => c\n          case None    => cur\n\n        for {\n          did <- c.downField(\"id\").as[Option[String]]\n          controller <- c\n            .downField(\"controller\")\n            .as[Option[String]]\n          alsoKnownAs <- c\n            .downField(\"alsoKnownAs\")\n            .as[Option[Set[String]]]\n          verificationMethod <- c\n            .downField(\"verificationMethod\")\n            .as[Option[Set[VerificationMethod]]]\n          keyAgreement: Option[Set[KeyAgreement]] <- c\n            .downField(\"keyAgreement\")\n            .as[Option[Set[KeyAgreement]]]\n          authentication: Option[Set[Authentication]] <- c\n            .downField(\"authentication\")\n            .as[Option[Set[Authentication]]]\n          assertionMethod <- c\n            .downField(\"assertionMethod\")\n            .as[Option[Set[Assertion]]]\n          capabilityInvocation <- c\n            .downField(\"capabilityInvocation\")\n            .as[Option[Set[CapabilityInvocation]]]\n          capabilityDelegations <- c\n            // .downField(\"didDocument\")\n            .downField(\"capabilityDelegations\")\n            .as[Option[Set[CapabilityDelegation]]]\n          didCommServices <- c\n            .downField(\"service\")\n            .as[Option[Set[Service]]]\n        } yield DIDDoc(\n          did.getOrElse(\"\"),\n          controller,\n          alsoKnownAs,\n          verificationMethod,\n          keyAgreement,\n          authentication,\n          assertionMethod,\n          capabilityInvocation,\n          capabilityDelegations,\n          didCommServices\n        )\n\n  given decodeVerificationMethod: Decoder[VerificationMethod] =\n    new Decoder[VerificationMethod]:\n      final def apply(c: HCursor): Decoder.Result[VerificationMethod] =\n        for {\n          id         <- c.downField(\"id\").as[String]\n          `type`     <- c.downField(\"type\").as[String]\n          controller <- c.downField(\"controller\").as[String]\n          verificationMaterial <- c\n            .downField(\"publicKeyJwk\")\n            .as[VerificationMaterialJWK]\n            .orElse(\n              c.downField(\"publicKeyMultibase\")\n                .as[VerificationMaterialMultibase]\n                .orElse(\n                  c.downField(\"publicKeyBase58\")\n                    .as[VerificationMaterialMultibase]\n                )\n            )\n\n        } yield VerificationMethod(\n          id,\n          VerificationMethodType.fromString(`type`),\n          verificationMaterial,\n          controller\n        )\n\n  given decodeVerificationMaterialJWK: Decoder[VerificationMaterialJWK] =\n    Decoder.forProduct4(\"crv\", \"x\", \"kty\", \"kid\")(VerificationMaterialJWK.apply)\n\n  given decodeVerificationMaterialMultibase: Decoder[VerificationMaterialMultibase] =\n    new Decoder[VerificationMaterialMultibase]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[VerificationMaterialMultibase] =\n        for {\n          value <- c.value.as[String]\n        } yield VerificationMaterialMultibase(value)\n\n  given decodeVerificationMaterial: Decoder[VerificationMaterial] =\n    decodeVerificationMaterialJWK\n      .widen[VerificationMaterial] or decodeVerificationMaterialMultibase\n      .widen[VerificationMaterial]\n\n  given decodeAuthenticationReference: Decoder[AuthenticationReference] =\n    new Decoder[AuthenticationReference]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[AuthenticationReference] =\n        for {\n          value <- c.value.as[String]\n        } yield AuthenticationReference(value)\n\n  given decodeAuthenticationInstance: Decoder[AuthenticationInstance] =\n    Decoder.forProduct4(\"id\", \"type\", \"controller\", \"publicKeyMultibase\")(\n      AuthenticationInstance.apply\n    )\n\n  given decodeAuthenticationRelationship: Decoder[Authentication] =\n    decodeAuthenticationReference\n      .widen[Authentication] or decodeAuthenticationInstance\n      .widen[Authentication]\n\n  given decodeAssertionInstance: Decoder[AssertionInstance] =\n    new Decoder[AssertionInstance]:\n      final def apply(c: HCursor): Decoder.Result[AssertionInstance] =\n        for {\n          id         <- c.downField(\"id\").as[String]\n          `type`     <- c.downField(\"type\").as[String]\n          controller <- c.downField(\"controller\").as[String]\n          publicKeyMultibase <- c\n            .downField(\"publicKeyMultibase\")\n            .as[String]\n            .orElse(\n              c.downField(\"publicKeyBase58\")\n                .as[String]\n            )\n        } yield AssertionInstance(\n          id,\n          `type`,\n          controller,\n          publicKeyMultibase\n        )\n\n  given decodeAssertionReference: Decoder[AssertionReference] =\n    new Decoder[AssertionReference]:\n      final def apply(c: HCursor): Decoder.Result[AssertionReference] =\n        for {\n          value <- c.value.as[String]\n        } yield AssertionReference(value)\n\n  given decodeAssertion: Decoder[Assertion] =\n    decodeAssertionInstance.widen[Assertion] or decodeAssertionReference\n      .widen[Assertion]\n\n  given decodeKeyAgreementMethod: Decoder[KeyAgreementInstance] =\n    new Decoder[KeyAgreementInstance]:\n      final def apply(c: HCursor): Decoder.Result[KeyAgreementInstance] =\n        for {\n          id         <- c.downField(\"id\").as[String]\n          `type`     <- c.downField(\"type\").as[String]\n          controller <- c.downField(\"controller\").as[String]\n          publicKeyMultibase <- c\n            .downField(\"publicKeyMultibase\")\n            .as[String]\n            .orElse(\n              c.downField(\"publicKeyBase58\")\n                .as[String]\n            )\n        } yield KeyAgreementInstance(\n          id,\n          `type`,\n          controller,\n          publicKeyMultibase\n        )\n\n  given decodeKeyAgreementReference: Decoder[KeyAgreementReference] =\n    new Decoder[KeyAgreementReference]:\n      final def apply(c: HCursor): Decoder.Result[KeyAgreementReference] =\n        for {\n          value <- c.value.as[String]\n        } yield KeyAgreementReference(value)\n\n  given decodeKeyAgreement: Decoder[KeyAgreement] =\n    decodeKeyAgreementReference.widen[KeyAgreement] or decodeKeyAgreementMethod\n      .widen[KeyAgreement]\n\n  given decodeCapabilityInvocationInstance: Decoder[CapabilityInvocationInstance] =\n    new Decoder[CapabilityInvocationInstance]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[CapabilityInvocationInstance] =\n        for {\n          id         <- c.downField(\"id\").as[String]\n          `type`     <- c.downField(\"type\").as[String]\n          controller <- c.downField(\"controller\").as[String]\n          publicKeyMultibase <- c\n            .downField(\"publicKeyMultibase\")\n            .as[String]\n            .orElse(\n              c.downField(\"publicKeyBase58\")\n                .as[String]\n            )\n        } yield CapabilityInvocationInstance(\n          id,\n          `type`,\n          controller,\n          publicKeyMultibase\n        )\n\n  given decodeCapabilityInvocationReference: Decoder[CapabilityInvocationReference] =\n    new Decoder[CapabilityInvocationReference]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[CapabilityInvocationReference] =\n        for {\n          value <- c.value.as[String]\n        } yield CapabilityInvocationReference(value)\n\n  given decodeCapabilityInvocation: Decoder[CapabilityInvocation] =\n    decodeCapabilityInvocationInstance\n      .widen[CapabilityInvocation] or decodeCapabilityInvocationReference\n      .widen[CapabilityInvocation]\n\n  given decodeCapabilityDelegationInstance: Decoder[CapabilityDelegationInstance] =\n    new Decoder[CapabilityDelegationInstance]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[CapabilityDelegationInstance] =\n        for {\n          id         <- c.downField(\"id\").as[String]\n          `type`     <- c.downField(\"type\").as[String]\n          controller <- c.downField(\"controller\").as[String]\n          publicKeyMultibase <- c\n            .downField(\"publicKeyMultibase\")\n            .as[String]\n            .orElse(\n              c.downField(\"publicKeyBase58\")\n                .as[String]\n            )\n        } yield CapabilityDelegationInstance(\n          id,\n          `type`,\n          controller,\n          publicKeyMultibase\n        )\n\n  given decodeCapabilityDelegationReference: Decoder[CapabilityDelegationReference] =\n    new Decoder[CapabilityDelegationReference]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[CapabilityDelegationReference] =\n        for {\n          value <- c.value.as[String]\n        } yield CapabilityDelegationReference(value)\n\n  given decodeCapabilityDelegation: Decoder[CapabilityDelegation] =\n    decodeCapabilityDelegationInstance\n      .widen[CapabilityDelegation] or decodeCapabilityDelegationReference\n      .widen[CapabilityDelegation]\n\n  given decodeServiceEndpointURI: Decoder[ServiceEndpointURI] =\n    new Decoder[ServiceEndpointURI]:\n      final def apply(c: HCursor): Decoder.Result[ServiceEndpointURI] =\n        for {\n          value <- c.value.as[String]\n        } yield ServiceEndpointURI(new URI(value))\n\n  given decodeServiceEndpointDIDURL: Decoder[ServiceEndpointDIDURL] =\n    new Decoder[ServiceEndpointDIDURL]:\n      final def apply(c: HCursor): Decoder.Result[ServiceEndpointDIDURL] =\n        for {\n          did      <- c.downField(\"did\").as[String]\n          fragment <- c.value.as[String]\n        } yield ServiceEndpointDIDURL(did, fragment)\n\n  given decodeServiceEndpointDIDCommService: Decoder[ServiceEndpointDIDCommService] =\n    new Decoder[ServiceEndpointDIDCommService]:\n      final def apply(\n          c: HCursor\n      ): Decoder.Result[ServiceEndpointDIDCommService] =\n        for {\n          uri         <- c.downField(\"uri\").as[URI]\n          accept      <- c.downField(\"accept\").as[Option[Set[String]]]\n          routingKeys <- c.downField(\"routingKeys\").as[Option[Set[String]]]\n        } yield ServiceEndpointDIDCommService(uri, accept, routingKeys)\n\n  given decodeServiceEndpointNodes: Decoder[ServiceEndpointNodes] =\n    new Decoder[ServiceEndpointNodes]:\n      final def apply(c: HCursor): Decoder.Result[ServiceEndpointNodes] =\n        for {\n          nodes <- c.downField(\"nodes\").as[Set[URI]]\n        } yield ServiceEndpointNodes(nodes)\n\n  given decodeServiceEndpoint: Decoder[ServiceEndpoint] =\n    decodeServiceEndpointURI\n      .widen[ServiceEndpoint] or decodeServiceEndpointDIDURL\n      .widen[ServiceEndpoint] or decodeServiceEndpointDIDCommService\n      .widen[ServiceEndpoint] or decodeServiceEndpointNodes\n      .widen[ServiceEndpoint]\n\n  given decodeService: Decoder[Service] =\n    new Decoder[Service]:\n      final def apply(c: HCursor): Result[Service] =\n        for {\n          id <- c.downField(\"id\").as[String].orElse(Right(\"did:sov:123\"))\n          `type` <- c.downField(\"type\").focus match\n            case Some(value) if value.isString =>\n              Right(Set[String](value.asString.getOrElse(\"\")))\n            case Some(values) if values.isArray =>\n              Right(\n                values.asArray\n                  .map(_.map(_.asString.getOrElse(\"\")).toSet)\n                  .getOrElse(Set.empty[String])\n              )\n            case _ => Right(Set.empty[String])\n          serviceEndpoint <- c.downField(\"serviceEndpoint\").focus match\n            case Some(value) if value.isString =>\n              Right(\n                Set(ServiceEndpointURI(new URI(value.asString.getOrElse(\"\"))))\n              )\n            case Some(values) if values.isArray =>\n              values.as[Set[ServiceEndpoint]]\n            case Some(value) if value.isObject =>\n              value.as[ServiceEndpoint].map(Set(_))\n            case _ => Right(Set(ServiceEndpointURI(new URI(\"\"))))\n        } yield Service(\n          new URI(id),\n          `type`,\n          serviceEndpoint\n        )\n"
        }
    ]
}