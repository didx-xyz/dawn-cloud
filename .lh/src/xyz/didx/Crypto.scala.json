{
    "sourceFile": "src/xyz/didx/Crypto.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 126,
            "patches": [
                {
                    "date": 1697451216279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1697451222019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +0,0 @@\n-import sttp.tapir.Schema\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697451231963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,367 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+  def getKeyStore(password: String, keyStorePath: os.Path): IO[Either[Error, KeyStore]] =\n+    if (!os.exists(keyStorePath))\n+      createKeyStore(password, keyStorePath.toString())\n+    else\n+      loadKeyStore(password, keyStorePath.toString())\n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  def saveToJWKSet(jwk: ECKey): IO[Either[Error, Unit]] = IO {\n+    Try {\n+      val keystoreFile         = keyStorePath.toIO\n+      val keystoreOutputStream = new java.io.FileOutputStream(keystoreFile)\n+      val pubJson              = new JWKSet(jwk).toPublicJWKSet()\n+      keystoreOutputStream.write(pubJson.toString().getBytes())\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => ().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+  }\n+\n+  // store the private key keystore\n+  def storePrivateKey(\n+    keyStore: KeyStore,\n+    kp: OctetKeyPair,\n+    alias: String,\n+    password: String,\n+    certificate: X509Certificate\n+  ): IO[Either[Error, Unit]] = IO {\n+    Try {\n+      val certificateChain     = Array[java.security.cert.Certificate](certificate)\n+      keyStore.setKeyEntry(s\"$alias\",new Ed25519PrivateKeyParameters(kp.getD().decode(),0).asInstanceOf[PrivateKey], password.toCharArray(), certificateChain)\n+      val keystoreFile         = keyStorePath.toIO\n+      val keystoreOutputStream = new java.io.FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => ().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+  }\n+\n+  def getPrivateKey(alias: String, password: String): IO[Either[Error, ECPrivateKey]] =\n+    for\n+      keyStore   <- getKeyStore(password, keyStorePath)\n+      privateKey <- IO(keyStore.map { ks =>\n+                      ks.getKey(alias, password.toCharArray())\n+                        .asInstanceOf[ECPrivateKey]\n+                    })\n+    yield privateKey\n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697460233368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,19 +140,9 @@\n \n     } yield jwk // .computeThumbprint().toString()\n \n   // save the JWKSet to a file\n-  def saveToJWKSet(jwk: ECKey): IO[Either[Error, Unit]] = IO {\n-    Try {\n-      val keystoreFile         = keyStorePath.toIO\n-      val keystoreOutputStream = new java.io.FileOutputStream(keystoreFile)\n-      val pubJson              = new JWKSet(jwk).toPublicJWKSet()\n-      keystoreOutputStream.write(pubJson.toString().getBytes())\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => ().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-  }\n+  \n \n   // store the private key keystore\n   def storePrivateKey(\n     keyStore: KeyStore,\n"
                },
                {
                    "date": 1697460265284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,26 +143,9 @@\n   // save the JWKSet to a file\n   \n \n   // store the private key keystore\n-  def storePrivateKey(\n-    keyStore: KeyStore,\n-    kp: OctetKeyPair,\n-    alias: String,\n-    password: String,\n-    certificate: X509Certificate\n-  ): IO[Either[Error, Unit]] = IO {\n-    Try {\n-      val certificateChain     = Array[java.security.cert.Certificate](certificate)\n-      keyStore.setKeyEntry(s\"$alias\",new Ed25519PrivateKeyParameters(kp.getD().decode(),0).asInstanceOf[PrivateKey], password.toCharArray(), certificateChain)\n-      val keystoreFile         = keyStorePath.toIO\n-      val keystoreOutputStream = new java.io.FileOutputStream(keystoreFile)\n-      keyStore.store(keystoreOutputStream, password.toCharArray)\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => ().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-  }\n+ \n \n   def getPrivateKey(alias: String, password: String): IO[Either[Error, ECPrivateKey]] =\n     for\n       keyStore   <- getKeyStore(password, keyStorePath)\n"
                },
                {
                    "date": 1697460275372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,16 +145,9 @@\n \n   // store the private key keystore\n  \n \n-  def getPrivateKey(alias: String, password: String): IO[Either[Error, ECPrivateKey]] =\n-    for\n-      keyStore   <- getKeyStore(password, keyStorePath)\n-      privateKey <- IO(keyStore.map { ks =>\n-                      ks.getKey(alias, password.toCharArray())\n-                        .asInstanceOf[ECPrivateKey]\n-                    })\n-    yield privateKey\n+ \n \n   // get the private key from keystore\n   def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n     Try {\n"
                },
                {
                    "date": 1697460296684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,13 +56,9 @@\n   val TAG_SIZE          = 128 // bits\n \n   Security.addProvider(new BouncyCastleProvider())\n   // if the keystore file does not exist, create a new keystore file\n-  def getKeyStore(password: String, keyStorePath: os.Path): IO[Either[Error, KeyStore]] =\n-    if (!os.exists(keyStorePath))\n-      createKeyStore(password, keyStorePath.toString())\n-    else\n-      loadKeyStore(password, keyStorePath.toString())\n+ \n   // create a java keystore object\n \n   def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n     val keyStore = KeyStore.getInstance(\"JKS\")\n"
                },
                {
                    "date": 1697629378215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -325,5 +325,6 @@\n     } match {\n       case Success(value)     => Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n-  }\n\\ No newline at end of file\n+  }\n+  \n\\ No newline at end of file\n"
                },
                {
                    "date": 1697629399346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,5 +326,44 @@\n       case Success(value)     => Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n-  \n\\ No newline at end of file\n+\n+  def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n+     val algo                = (kty, crv) match\n+       case (\"EC\", \"P-256\") => \"zDn\"\n+       case (\"EC\", \"P-384\") => \"z82\"\n+       case (\"EC\", \"P-521\") => \"z2J9\"\n+       case _               => \"\"\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:$a$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697630542162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,12 +329,14 @@\n   }\n \n   def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n      val algo                = (kty, crv) match\n-       case (\"EC\", \"P-256\") => \"zDn\"\n-       case (\"EC\", \"P-384\") => \"z82\"\n-       case (\"EC\", \"P-521\") => \"z2J9\"\n-       case _               => \"\"\n+      case (\"EC\", \"P-256\") => \"zDn\"\n+          case (\"EC\", \"P-384\") => \"z82\"\n+          case (\"EC\", \"P-521\") => \"z2J9\"\n+          case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n+          case (\"OKP\", \"X25519\")  => \"z6LS\"\n+          case (\"RSA\", _)         => \"z13\"\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697630550321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,13 +330,13 @@\n \n   def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n      val algo                = (kty, crv) match\n       case (\"EC\", \"P-256\") => \"zDn\"\n-          case (\"EC\", \"P-384\") => \"z82\"\n-          case (\"EC\", \"P-521\") => \"z2J9\"\n-          case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n-          case (\"OKP\", \"X25519\")  => \"z6LS\"\n-          case (\"RSA\", _)         => \"z13\"\n+        case (\"EC\", \"P-384\") => \"z82\"\n+        case (\"EC\", \"P-521\") => \"z2J9\"\n+        case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n+        case (\"OKP\", \"X25519\")  => \"z6LS\"\n+        case (\"RSA\", _)         => \"z13\"\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697630560059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,9 +329,9 @@\n   }\n \n   def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n      val algo                = (kty, crv) match\n-      case (\"EC\", \"P-256\") => \"zDn\"\n+       case (\"EC\", \"P-256\") => \"zDn\"\n         case (\"EC\", \"P-384\") => \"z82\"\n         case (\"EC\", \"P-521\") => \"z2J9\"\n         case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n         case (\"OKP\", \"X25519\")  => \"z6LS\"\n"
                },
                {
                    "date": 1697630569034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,13 +330,13 @@\n \n   def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n      val algo                = (kty, crv) match\n        case (\"EC\", \"P-256\") => \"zDn\"\n-        case (\"EC\", \"P-384\") => \"z82\"\n-        case (\"EC\", \"P-521\") => \"z2J9\"\n-        case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n-        case (\"OKP\", \"X25519\")  => \"z6LS\"\n-        case (\"RSA\", _)         => \"z13\"\n+      case (\"EC\", \"P-384\") => \"z82\"\n+      case (\"EC\", \"P-521\") => \"z2J9\"\n+      case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n+      case (\"OKP\", \"X25519\")  => \"z6LS\"\n+      case (\"RSA\", _)         => \"z13\"\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635175004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,16 +327,16 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def makeDidKey(pubKey: PublicKey, kty: String, crv: String): Option[String] =\n+  def makeDidKey(kty: String, crv: String): Option[String] =\n      val algo                = (kty, crv) match\n-       case (\"EC\", \"P-256\") => \"zDn\"\n-      case (\"EC\", \"P-384\") => \"z82\"\n-      case (\"EC\", \"P-521\") => \"z2J9\"\n-      case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n-      case (\"OKP\", \"X25519\")  => \"z6LS\"\n-      case (\"RSA\", _)         => \"z13\"\n+        case (\"EC\", \"P-256\") => \"zDn\"\n+        case (\"EC\", \"P-384\") => \"z82\"\n+        case (\"EC\", \"P-521\") => \"z2J9\"\n+        case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n+        case (\"OKP\", \"X25519\")  => \"z6LS\"\n+        case (\"RSA\", _)         => \"z13\"\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635182540,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,9 +327,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def makeDidKey(kty: String, crv: String): Option[String] =\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey, pubKey: PublicKey, ): Option[String] =\n      val algo                = (kty, crv) match\n         case (\"EC\", \"P-256\") => \"zDn\"\n         case (\"EC\", \"P-384\") => \"z82\"\n         case (\"EC\", \"P-521\") => \"z2J9\"\n"
                },
                {
                    "date": 1697635188293,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,9 +327,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def makeDidKey(kty: String, crv: String, pubKey: PublicKey, pubKey: PublicKey, ): Option[String] =\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n      val algo                = (kty, crv) match\n         case (\"EC\", \"P-256\") => \"zDn\"\n         case (\"EC\", \"P-384\") => \"z82\"\n         case (\"EC\", \"P-521\") => \"z2J9\"\n"
                },
                {
                    "date": 1697635211422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,15 +328,9 @@\n     }\n   }\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo                = (kty, crv) match\n-        case (\"EC\", \"P-256\") => \"zDn\"\n-        case (\"EC\", \"P-384\") => \"z82\"\n-        case (\"EC\", \"P-521\") => \"z2J9\"\n-        case (\"OKP\", \"Ed25519\") => \"z6Mk\"\n-        case (\"OKP\", \"X25519\")  => \"z6LS\"\n-        case (\"RSA\", _)         => \"z13\"\n+     \n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635226639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,9 @@\n     }\n   }\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     \n+     val algo = Al\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635288016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,9 @@\n     }\n   }\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = Al\n+     val algo = xyz.Algorithm(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635294481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,9 @@\n     }\n   }\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.Algorithm(kty, crv)\n+     val algo = xyz.didx.Al(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n"
                },
                {
                    "date": 1697635383137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,14 +328,14 @@\n     }\n   }\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.didx.Al(kty, crv)\n+     val algo = xyz.didx.Algorithm(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:$a$k\")\n+       case (a, Some(k)) => Some(s\"did:key:$a.$k\")\n        case _            => None\n \n   val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n \n"
                },
                {
                    "date": 1697635390431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,9 +333,9 @@\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:$a.$k\")\n+       case (a, Some(k)) => Some(s\"did:key:${a.}$k\")\n        case _            => None\n \n   val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n \n"
                },
                {
                    "date": 1697635402366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,9 +333,9 @@\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n        case null           => None\n      (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:${a.}$k\")\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n        case _            => None\n \n   val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n \n"
                },
                {
                    "date": 1697706966075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,366 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+ \n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  \n+\n+  // store the private key keystore\n+ \n+\n+ \n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n+     val algo = xyz.didx.Algorithm(kty, crv)\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n+  \n\\ No newline at end of file\n"
                },
                {
                    "date": 1697706980819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -362,370 +362,23 @@\n         .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n         .toByteArray\n         .dropWhile(_ == 0.toByte)\n   }\n-  \n-package xyz.didx\n+  def encodeB(input: Seq[Byte]): String = {\n+     if (input.isEmpty) \"\"\n+     else {\n+       val big = new BigInteger(1, input.toArray)\n+       val builder = new StringBuilder\n \n-import java.security.KeyStore\n-import java.security.KeyPair\n-import java.security.KeyPairGenerator\n-import java.security.Key\n-\n-import cats.implicits._\n-import cats.effect.IO\n-\n-import java.security.KeyFactory\n-import java.security.spec.X509EncodedKeySpec\n-import java.security.KeyStore.TrustedCertificateEntry\n-import java.util.Base64\n-import java.security.PublicKey\n-import com.nimbusds.jose.*\n-import com.nimbusds.jose.crypto.*\n-import com.nimbusds.jose.jwk.*\n-import com.nimbusds.jose.jwk.gen.*\n-import com.nimbusds.jose.jwk.JWKSet\n-import java.nio.file.Paths\n-import java.io.FileOutputStream\n-import java.io.FileInputStream\n-import java.security.Security\n-import org.bouncycastle.jce.provider.BouncyCastleProvider\n-import java.security.cert.X509Certificate\n-import org.bouncycastle.asn1.x500.X500Name\n-import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n-import org.bouncycastle.cert.X509v3CertificateBuilder\n-import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n-import java.math.BigInteger\n-import java.util.Date\n-import java.security.interfaces.ECPrivateKey\n-import java.security.interfaces.ECPublicKey\n-import scala.util.Try\n-import scala.util.{Success, Failure}\n-import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n-import org.bouncycastle.crypto.params.ECPublicKeyParameters\n-import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n-import java.security.PrivateKey\n-import org.bouncycastle.crypto.digests.SHA256Digest\n-import org.bouncycastle.crypto.params.KDFParameters\n-import org.bouncycastle.jce.ECNamedCurveTable\n-import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n-import org.bouncycastle.crypto.params.ECDomainParameters\n-import org.bouncycastle.math.ec.ECPoint\n-import javax.crypto.Cipher\n-import javax.crypto.spec.SecretKeySpec\n-import javax.crypto.spec.GCMParameterSpec\n-import java.util.Base64\n-import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n-\n-object Crypto:\n-  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n-  val IV_SIZE           = 12  // bytes\n-  val TAG_SIZE          = 128 // bits\n-\n-  Security.addProvider(new BouncyCastleProvider())\n-  // if the keystore file does not exist, create a new keystore file\n- \n-  // create a java keystore object\n-\n-  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      keyStore.load(null, password.toCharArray)\n-      val keystoreFile         = Paths.get(keystorePath).toFile\n-      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n-      keyStore.store(keystoreOutputStream, password.toCharArray)\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      val keystoreFile        = Paths.get(keystorePath).toFile\n-      val keystoreInputStream = new FileInputStream(keystoreFile)\n-      keyStore.load(keystoreInputStream, password.toCharArray)\n-      keystoreInputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  // create a RSA key pair using java.security.KeyPairGenerator\n-  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n-    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-    keyPairGenerator.initialize(2048)\n-    Try {\n-      keyPairGenerator.generateKeyPair()\n-    } match\n-      case Success(keyPair)   => keyPair.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-  }\n-\n-  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n-      Try {\n-        keyPairGenerator.generateKeyPair()\n-      } match\n-        case Success(keyPair)   => keyPair.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-\n-    }\n-\n-\n-  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n-  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new OctetKeyPairGenerator(Curve.Ed25519)\n-                 .keyID(alias)\n-                 .generate()\n-\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n-\n-    } yield jwk\n-\n-  // create a EC P-384 key pair\n-  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-\n-               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n-\n-    } yield jwk // .computeThumbprint().toString()\n-\n-  // save the JWKSet to a file\n-  \n-\n-  // store the private key keystore\n- \n-\n- \n-\n-  // get the private key from keystore\n-  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n-    Try {\n-      keyStore.getKey(alias, password.toCharArray())\n-    } match\n-      case Success(key)       => key.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n-  }\n-\n-  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-\n-    Try {\n-      val jweObject = JWEObject.parse(encryptedMessage)\n-      jweObject.decrypt(new ECDHDecrypter(privateKey))\n-      jweObject.getPayload().toString()\n-    } match\n-      case Success(message)   => message.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-\n-  }\n-\n-  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val o = new JWEObject(\n-        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n-          .keyID(publicKey.toString())\n-          .build(),\n-        new Payload(message)\n-      )\n-      o.encrypt(new ECDHEncrypter(publicKey))\n-      o.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val jwsObject = new JWSObject(\n-        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n-        new Payload(message)\n-      )\n-      jwsObject.sign(new ECDSASigner(privateKey))\n-      jwsObject.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n-  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    val jwsObject = JWSObject.parse(message)\n-    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n-      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    val jweObject = JWEObject.parse(message)\n-    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n-      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  } */\n-\n-  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n-\n-  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n-    Try {\n-      Security.addProvider(new BouncyCastleProvider())\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-      keyPairGenerator.initialize(2048)\n-      val keyPair          = keyPairGenerator.generateKeyPair()\n-      val subject          = new X500Name(s\"CN=$alias\")\n-      val issuer           = subject\n-      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n-      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n-      val notAfter         =\n-        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n-      val pubKey        =\n-        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n-      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n-      val certBuilder   = new X509v3CertificateBuilder(\n-        issuer,\n-        serialNumber,\n-        notBefore,\n-        notAfter,\n-        subject,\n-        publicKeyInfo\n-      )\n-      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n-      val certHolder    = certBuilder.build(contentSigner)\n-      val certConverter = JcaX509CertificateConverter()\n-      certConverter.getCertificate(certHolder)\n-    } match\n-      case Success(certificate) => certificate.asRight[Error]\n-      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n-  }\n-\n-  def storeCertificate(\n-    keyStore: KeyStore,\n-    certificate: X509Certificate,\n-    alias: String,\n-    password: Array[Char]\n-  ): IO[Either[Error, Unit]] =\n-    IO {\n-      Try {\n-        keyStore.setCertificateEntry(alias, certificate)\n-      } match\n-        case Success(_)         => ().asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-    }\n-    // Save the keystore to a file or perform any other necessary operations\n-\n-  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n-    val keyBytes   = Base64.getDecoder.decode(base64String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n-    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n-\n-  def computeSharedSecret(\n-    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n-    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n-    nonce: Array[Byte]\n-  ): IO[Either[Error, Array[Byte]]] =\n-    IO {\n-      Try {\n-        val agreement        = new ECDHBasicAgreement()\n-        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n-        val domainParams     =\n-          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n-        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n-        agreement.init(privateKeyParams)\n-\n-        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n-        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n-\n-        // Convert shared secret to bytes\n-        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n-\n-        // Derive AES key using KDF (with nonce/salt)\n-        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n-        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n-\n-        val aesKey = new Array[Byte](32) // For AES-256\n-        kdf.generateBytes(aesKey, 0, aesKey.length)\n-        aesKey\n-      } match\n-        case Success(s)         => s.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n-    }\n-\n-  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val iv     = new Array[Byte](IV_SIZE)\n-      new java.security.SecureRandom().nextBytes(iv)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n-      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n-      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n-      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n-      new String(decrypted, \"UTF-8\")\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.didx.Algorithm(kty, crv)\n-     val key: Option[String] = pubKey.getEncoded() match\n-       case b: Array[Byte] => Some(encodeToBase58(b))\n-       case null           => None\n-     (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n-       case _            => None\n-\n-  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n-\n-  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n-\n-  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n-\n-  def encodeToBase58(array: Array[Byte]): String =\n-    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n-      .unfold(\n-        BigInt(0.toByte +: array)\n-      )(n => if (n == 0) None else Some((n /% 58).swap))\n-      .map(_.toInt)\n-      .reverse\n-      .map(x => idxToChar(x))).mkString\n-\n-  def decodeFromBase58(b58: String): Array[Byte] = {\n-    val zeroCount = b58.takeWhile(_ == '1').length\n-    Array.fill(zeroCount)(0.toByte) ++\n-      b58\n-        .drop(zeroCount)\n-        .map(charToIdx)\n\\ No newline at end of file\n-        .toList\n-        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n-        .toByteArray\n-        .dropWhile(_ == 0.toByte)\n-  }\n+       @tailrec\n+       def encode1(current: BigInteger): Unit = current match {\n+         case BigInteger.ZERO => ()\n+         case _ =>\n+           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n+           builder.append(alphabet.charAt(remainder.intValue))\n+           encode1(x)\n+       }\n+       encode1(big)\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabet.charAt(0)))\n+       builder.toString().reverse\n+     }\n+   }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697706998955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,11 @@\n import javax.crypto.spec.SecretKeySpec\n import javax.crypto.spec.GCMParameterSpec\n import java.util.Base64\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+import scala.annotation.tailrec\n \n+\n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n   val IV_SIZE           = 12  // bytes\n   val TAG_SIZE          = 128 // bits\n@@ -362,9 +364,9 @@\n         .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n         .toByteArray\n         .dropWhile(_ == 0.toByte)\n   }\n-  def encodeB(input: Seq[Byte]): String = {\n+  def encodeB58(input: Seq[Byte]): String = {\n      if (input.isEmpty) \"\"\n      else {\n        val big = new BigInteger(1, input.toArray)\n        val builder = new StringBuilder\n"
                },
                {
                    "date": 1697707023992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -375,9 +375,9 @@\n        def encode1(current: BigInteger): Unit = current match {\n          case BigInteger.ZERO => ()\n          case _ =>\n            val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n-           builder.append(alphabet.charAt(remainder.intValue))\n+           builder.append(alphabetBase58.charAt(remainder.intValue))\n            encode1(x)\n        }\n        encode1(big)\n        input.takeWhile(_ == 0).map(_ => builder.append(alphabet.charAt(0)))\n"
                },
                {
                    "date": 1697792311690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,8 +267,10 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n+    \n+\n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n@@ -379,8 +381,8 @@\n            builder.append(alphabetBase58.charAt(remainder.intValue))\n            encode1(x)\n        }\n        encode1(big)\n-       input.takeWhile(_ == 0).map(_ => builder.append(alphabet.charAt(0)))\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n        builder.toString().reverse\n      }\n    }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697792318534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,9 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n-    \n+  def get\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697792325772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,9 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n-  def get\n+  def getECPublicKey\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697792334545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,9 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n-  def getECPublicKey\n+  def getECPublicKeyFrom\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697792340996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,9 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n-  def getECPublicKeyFrom\n+  def getECPublicKeyFromBase58\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697792353912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,13 @@\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n-  def getECPublicKeyFromBase58\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697794243453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,8 +321,10 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n+  de\n+\n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n       val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n"
                },
                {
                    "date": 1697794251777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  de\n+  def encrypt\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n"
                },
                {
                    "date": 1697794268154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt\n+  def encrypt(key\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n"
                },
                {
                    "date": 1697794304719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key\n+  def encrypt(key: EC\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n"
                },
                {
                    "date": 1697794310744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key: EC\n+  def encrypt(key: ECPublicKey\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n"
                },
                {
                    "date": 1697794329754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key: ECPublicKey\n+  def encrypt(key: ECPublicKey,\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n"
                },
                {
                    "date": 1697794337560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,394 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+import scala.annotation.tailrec\n+\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+ \n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  \n+\n+  // store the private key keystore\n+ \n+\n+ \n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def encrypt(key: ECPublicKey, text:String\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n+     val algo = xyz.didx.Algorithm(kty, crv)\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n+  def encodeB58(input: Seq[Byte]): String = {\n+     if (input.isEmpty) \"\"\n+     else {\n+       val big = new BigInteger(1, input.toArray)\n+       val builder = new StringBuilder\n+\n+       @tailrec\n+       def encode1(current: BigInteger): Unit = current match {\n+         case BigInteger.ZERO => ()\n+         case _ =>\n+           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n+           builder.append(alphabetBase58.charAt(remainder.intValue))\n+           encode1(x)\n+       }\n+       encode1(big)\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n+       builder.toString().reverse\n+     }\n+   }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697794347934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,394 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+import scala.annotation.tailrec\n+\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+ \n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  \n+\n+  // store the private key keystore\n+ \n+\n+ \n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def encrypt(key: ECPublicKey, text:String\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n+     val algo = xyz.didx.Algorithm(kty, crv)\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n+  def encodeB58(input: Seq[Byte]): String = {\n+     if (input.isEmpty) \"\"\n+     else {\n+       val big = new BigInteger(1, input.toArray)\n+       val builder = new StringBuilder\n+\n+       @tailrec\n+       def encode1(current: BigInteger): Unit = current match {\n+         case BigInteger.ZERO => ()\n+         case _ =>\n+           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n+           builder.append(alphabetBase58.charAt(remainder.intValue))\n+           encode1(x)\n+       }\n+       encode1(big)\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n+       builder.toString().reverse\n+     }\n+   }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697794547961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,404 +321,24 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key: ECPublicKey, text:String\n-\n-  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+  def encrypt(key: PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n-      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n-      new String(decrypted, \"UTF-8\")\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.didx.Algorithm(kty, crv)\n-     val key: Option[String] = pubKey.getEncoded() match\n-       case b: Array[Byte] => Some(encodeToBase58(b))\n-       case null           => None\n-     (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n-       case _            => None\n-\n-  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n-\n-  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n-\n-  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n-\n-  def encodeToBase58(array: Array[Byte]): String =\n-    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n-      .unfold(\n-        BigInt(0.toByte +: array)\n-      )(n => if (n == 0) None else Some((n /% 58).swap))\n-      .map(_.toInt)\n-      .reverse\n-      .map(x => idxToChar(x))).mkString\n-\n-  def decodeFromBase58(b58: String): Array[Byte] = {\n-    val zeroCount = b58.takeWhile(_ == '1').length\n-    Array.fill(zeroCount)(0.toByte) ++\n-      b58\n-        .drop(zeroCount)\n-        .map(charToIdx)\n-        .toList\n-        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n-        .toByteArray\n-        .dropWhile(_ == 0.toByte)\n-  }\n-  def encodeB58(input: Seq[Byte]): String = {\n-     if (input.isEmpty) \"\"\n-     else {\n-       val big = new BigInteger(1, input.toArray)\n-       val builder = new StringBuilder\n-\n-       @tailrec\n-       def encode1(current: BigInteger): Unit = current match {\n-         case BigInteger.ZERO => ()\n-         case _ =>\n-           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n-           builder.append(alphabetBase58.charAt(remainder.intValue))\n-           encode1(x)\n-       }\n-       encode1(big)\n-       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n-       builder.toString().reverse\n-     }\n-   }\n-package xyz.didx\n-\n-import java.security.KeyStore\n-import java.security.KeyPair\n-import java.security.KeyPairGenerator\n-import java.security.Key\n-\n-import cats.implicits._\n-import cats.effect.IO\n-\n-import java.security.KeyFactory\n-import java.security.spec.X509EncodedKeySpec\n-import java.security.KeyStore.TrustedCertificateEntry\n-import java.util.Base64\n-import java.security.PublicKey\n-import com.nimbusds.jose.*\n-import com.nimbusds.jose.crypto.*\n-import com.nimbusds.jose.jwk.*\n-import com.nimbusds.jose.jwk.gen.*\n-import com.nimbusds.jose.jwk.JWKSet\n-import java.nio.file.Paths\n-import java.io.FileOutputStream\n-import java.io.FileInputStream\n-import java.security.Security\n-import org.bouncycastle.jce.provider.BouncyCastleProvider\n-import java.security.cert.X509Certificate\n-import org.bouncycastle.asn1.x500.X500Name\n-import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n-import org.bouncycastle.cert.X509v3CertificateBuilder\n-import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n-import java.math.BigInteger\n-import java.util.Date\n-import java.security.interfaces.ECPrivateKey\n-import java.security.interfaces.ECPublicKey\n-import scala.util.Try\n-import scala.util.{Success, Failure}\n-import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n-import org.bouncycastle.crypto.params.ECPublicKeyParameters\n-import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n-import java.security.PrivateKey\n-import org.bouncycastle.crypto.digests.SHA256Digest\n-import org.bouncycastle.crypto.params.KDFParameters\n-import org.bouncycastle.jce.ECNamedCurveTable\n-import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n-import org.bouncycastle.crypto.params.ECDomainParameters\n-import org.bouncycastle.math.ec.ECPoint\n-import javax.crypto.Cipher\n-import javax.crypto.spec.SecretKeySpec\n-import javax.crypto.spec.GCMParameterSpec\n-import java.util.Base64\n-import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n-import scala.annotation.tailrec\n-\n-\n-object Crypto:\n-  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n-  val IV_SIZE           = 12  // bytes\n-  val TAG_SIZE          = 128 // bits\n-\n-  Security.addProvider(new BouncyCastleProvider())\n-  // if the keystore file does not exist, create a new keystore file\n- \n-  // create a java keystore object\n-\n-  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      keyStore.load(null, password.toCharArray)\n-      val keystoreFile         = Paths.get(keystorePath).toFile\n-      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n-      keyStore.store(keystoreOutputStream, password.toCharArray)\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      val keystoreFile        = Paths.get(keystorePath).toFile\n-      val keystoreInputStream = new FileInputStream(keystoreFile)\n-      keyStore.load(keystoreInputStream, password.toCharArray)\n-      keystoreInputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  // create a RSA key pair using java.security.KeyPairGenerator\n-  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n-    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-    keyPairGenerator.initialize(2048)\n-    Try {\n-      keyPairGenerator.generateKeyPair()\n-    } match\n-      case Success(keyPair)   => keyPair.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-  }\n-\n-  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n-      Try {\n-        keyPairGenerator.generateKeyPair()\n-      } match\n-        case Success(keyPair)   => keyPair.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-\n-    }\n-\n-\n-  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n-  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new OctetKeyPairGenerator(Curve.Ed25519)\n-                 .keyID(alias)\n-                 .generate()\n-\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n-\n-    } yield jwk\n-\n-  // create a EC P-384 key pair\n-  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-\n-               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n-\n-    } yield jwk // .computeThumbprint().toString()\n-\n-  // save the JWKSet to a file\n-  \n-\n-  // store the private key keystore\n- \n-\n- \n-\n-  // get the private key from keystore\n-  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n-    Try {\n-      keyStore.getKey(alias, password.toCharArray())\n-    } match\n-      case Success(key)       => key.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n-  }\n-\n-  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-\n-    Try {\n-      val jweObject = JWEObject.parse(encryptedMessage)\n-      jweObject.decrypt(new ECDHDecrypter(privateKey))\n-      jweObject.getPayload().toString()\n-    } match\n-      case Success(message)   => message.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-\n-  }\n-\n-  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val o = new JWEObject(\n-        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n-          .keyID(publicKey.toString())\n-          .build(),\n-        new Payload(message)\n-      )\n-      o.encrypt(new ECDHEncrypter(publicKey))\n-      o.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val jwsObject = new JWSObject(\n-        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n-        new Payload(message)\n-      )\n-      jwsObject.sign(new ECDSASigner(privateKey))\n-      jwsObject.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n-  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    val jwsObject = JWSObject.parse(message)\n-    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n-      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    val jweObject = JWEObject.parse(message)\n-    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n-      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  } */\n-\n-  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n-\n-  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n-    Try {\n-      Security.addProvider(new BouncyCastleProvider())\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-      keyPairGenerator.initialize(2048)\n-      val keyPair          = keyPairGenerator.generateKeyPair()\n-      val subject          = new X500Name(s\"CN=$alias\")\n-      val issuer           = subject\n-      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n-      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n-      val notAfter         =\n-        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n-      val pubKey        =\n-        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n-      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n-      val certBuilder   = new X509v3CertificateBuilder(\n-        issuer,\n-        serialNumber,\n-        notBefore,\n-        notAfter,\n-        subject,\n-        publicKeyInfo\n-      )\n-      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n-      val certHolder    = certBuilder.build(contentSigner)\n-      val certConverter = JcaX509CertificateConverter()\n-      certConverter.getCertificate(certHolder)\n-    } match\n-      case Success(certificate) => certificate.asRight[Error]\n-      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n-  }\n-\n-  def storeCertificate(\n-    keyStore: KeyStore,\n-    certificate: X509Certificate,\n-    alias: String,\n-    password: Array[Char]\n-  ): IO[Either[Error, Unit]] =\n-    IO {\n-      Try {\n-        keyStore.setCertificateEntry(alias, certificate)\n-      } match\n-        case Success(_)         => ().asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-    }\n-    // Save the keystore to a file or perform any other necessary operations\n-\n-  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n-    val keyBytes   = Base64.getDecoder.decode(base64String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n-    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n-\n-  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n-    val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EC\")\n-    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-\n-  def computeSharedSecret(\n-    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n-    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n-    nonce: Array[Byte]\n-  ): IO[Either[Error, Array[Byte]]] =\n-    IO {\n-      Try {\n-        val agreement        = new ECDHBasicAgreement()\n-        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n-        val domainParams     =\n-          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n-        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n-        agreement.init(privateKeyParams)\n-\n-        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n-        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n-\n-        // Convert shared secret to bytes\n-        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n-\n-        // Derive AES key using KDF (with nonce/salt)\n-        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n-        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n-\n-        val aesKey = new Array[Byte](32) // For AES-256\n-        kdf.generateBytes(aesKey, 0, aesKey.length)\n-        aesKey\n-      } match\n-        case Success(s)         => s.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n-    }\n-\n-  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n       val iv     = new Array[Byte](IV_SIZE)\n       new java.security.SecureRandom().nextBytes(iv)\n       val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n-      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+      cipher.init(Cipher.ENCRYPT_MODE, key, spec)\n \n-      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n       (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n     } match {\n       case Success(value)     => Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key: ECPublicKey, text:String\n-\n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n       val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n@@ -784,399 +404,5 @@\n        encode1(big)\n        input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n        builder.toString().reverse\n      }\n-   }\n-package xyz.didx\n-\n-import java.security.KeyStore\n-import java.security.KeyPair\n-import java.security.KeyPairGenerator\n-import java.security.Key\n-\n-import cats.implicits._\n-import cats.effect.IO\n-\n-import java.security.KeyFactory\n-import java.security.spec.X509EncodedKeySpec\n-import java.security.KeyStore.TrustedCertificateEntry\n-import java.util.Base64\n-import java.security.PublicKey\n-import com.nimbusds.jose.*\n-import com.nimbusds.jose.crypto.*\n-import com.nimbusds.jose.jwk.*\n-import com.nimbusds.jose.jwk.gen.*\n-import com.nimbusds.jose.jwk.JWKSet\n-import java.nio.file.Paths\n-import java.io.FileOutputStream\n-import java.io.FileInputStream\n-import java.security.Security\n-import org.bouncycastle.jce.provider.BouncyCastleProvider\n-import java.security.cert.X509Certificate\n-import org.bouncycastle.asn1.x500.X500Name\n-import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n-import org.bouncycastle.cert.X509v3CertificateBuilder\n-import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n-import java.math.BigInteger\n-import java.util.Date\n-import java.security.interfaces.ECPrivateKey\n-import java.security.interfaces.ECPublicKey\n-import scala.util.Try\n-import scala.util.{Success, Failure}\n-import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n-import org.bouncycastle.crypto.params.ECPublicKeyParameters\n-import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n-import java.security.PrivateKey\n-import org.bouncycastle.crypto.digests.SHA256Digest\n-import org.bouncycastle.crypto.params.KDFParameters\n-import org.bouncycastle.jce.ECNamedCurveTable\n-import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n-import org.bouncycastle.crypto.params.ECDomainParameters\n-import org.bouncycastle.math.ec.ECPoint\n-import javax.crypto.Cipher\n-import javax.crypto.spec.SecretKeySpec\n-import javax.crypto.spec.GCMParameterSpec\n-import java.util.Base64\n-import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n-import scala.annotation.tailrec\n-\n-\n-object Crypto:\n-  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n-  val IV_SIZE           = 12  // bytes\n-  val TAG_SIZE          = 128 // bits\n-\n-  Security.addProvider(new BouncyCastleProvider())\n-  // if the keystore file does not exist, create a new keystore file\n- \n-  // create a java keystore object\n-\n-  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      keyStore.load(null, password.toCharArray)\n-      val keystoreFile         = Paths.get(keystorePath).toFile\n-      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n-      keyStore.store(keystoreOutputStream, password.toCharArray)\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      val keystoreFile        = Paths.get(keystorePath).toFile\n-      val keystoreInputStream = new FileInputStream(keystoreFile)\n-      keyStore.load(keystoreInputStream, password.toCharArray)\n-      keystoreInputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  // create a RSA key pair using java.security.KeyPairGenerator\n-  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n-    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-    keyPairGenerator.initialize(2048)\n-    Try {\n-      keyPairGenerator.generateKeyPair()\n-    } match\n-      case Success(keyPair)   => keyPair.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-  }\n-\n-  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n-      Try {\n-        keyPairGenerator.generateKeyPair()\n-      } match\n-        case Success(keyPair)   => keyPair.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-\n-    }\n-\n-\n-  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n-  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new OctetKeyPairGenerator(Curve.Ed25519)\n-                 .keyID(alias)\n-                 .generate()\n-\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n-\n-    } yield jwk\n-\n-  // create a EC P-384 key pair\n-  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-\n-               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n-\n-    } yield jwk // .computeThumbprint().toString()\n-\n-  // save the JWKSet to a file\n-  \n-\n-  // store the private key keystore\n- \n-\n- \n-\n-  // get the private key from keystore\n-  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n-    Try {\n-      keyStore.getKey(alias, password.toCharArray())\n-    } match\n-      case Success(key)       => key.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n-  }\n-\n-  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-\n-    Try {\n-      val jweObject = JWEObject.parse(encryptedMessage)\n-      jweObject.decrypt(new ECDHDecrypter(privateKey))\n-      jweObject.getPayload().toString()\n-    } match\n-      case Success(message)   => message.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-\n-  }\n-\n-  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val o = new JWEObject(\n-        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n-          .keyID(publicKey.toString())\n-          .build(),\n-        new Payload(message)\n-      )\n-      o.encrypt(new ECDHEncrypter(publicKey))\n-      o.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val jwsObject = new JWSObject(\n-        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n-        new Payload(message)\n-      )\n-      jwsObject.sign(new ECDSASigner(privateKey))\n-      jwsObject.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n-  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    val jwsObject = JWSObject.parse(message)\n-    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n-      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    val jweObject = JWEObject.parse(message)\n-    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n-      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  } */\n-\n-  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n-\n-  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n-    Try {\n-      Security.addProvider(new BouncyCastleProvider())\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-      keyPairGenerator.initialize(2048)\n-      val keyPair          = keyPairGenerator.generateKeyPair()\n-      val subject          = new X500Name(s\"CN=$alias\")\n-      val issuer           = subject\n-      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n-      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n-      val notAfter         =\n-        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n-      val pubKey        =\n-        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n-      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n-      val certBuilder   = new X509v3CertificateBuilder(\n-        issuer,\n-        serialNumber,\n-        notBefore,\n-        notAfter,\n-        subject,\n-        publicKeyInfo\n-      )\n-      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n-      val certHolder    = certBuilder.build(contentSigner)\n-      val certConverter = JcaX509CertificateConverter()\n-      certConverter.getCertificate(certHolder)\n-    } match\n-      case Success(certificate) => certificate.asRight[Error]\n-      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n-  }\n-\n-  def storeCertificate(\n-    keyStore: KeyStore,\n-    certificate: X509Certificate,\n-    alias: String,\n-    password: Array[Char]\n-  ): IO[Either[Error, Unit]] =\n-    IO {\n-      Try {\n-        keyStore.setCertificateEntry(alias, certificate)\n-      } match\n-        case Success(_)         => ().asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-    }\n-    // Save the keystore to a file or perform any other necessary operations\n-\n-  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n-    val keyBytes   = Base64.getDecoder.decode(base64String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n-    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n-\n-  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n-    val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EC\")\n-    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-\n-  def computeSharedSecret(\n-    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n-    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n-    nonce: Array[Byte]\n-  ): IO[Either[Error, Array[Byte]]] =\n-    IO {\n-      Try {\n-        val agreement        = new ECDHBasicAgreement()\n-        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n-        val domainParams     =\n-          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n-        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n-        agreement.init(privateKeyParams)\n-\n-        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n-        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n-\n-        // Convert shared secret to bytes\n-        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n-\n-        // Derive AES key using KDF (with nonce/salt)\n-        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n-        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n-\n-        val aesKey = new Array[Byte](32) // For AES-256\n-        kdf.generateBytes(aesKey, 0, aesKey.length)\n-        aesKey\n-      } match\n-        case Success(s)         => s.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n-    }\n-\n-  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val iv     = new Array[Byte](IV_SIZE)\n-      new java.security.SecureRandom().nextBytes(iv)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n-      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n-      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def encrypt(key: ECPublicKey,\n-\n-  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n-      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n-      new String(decrypted, \"UTF-8\")\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.didx.Algorithm(kty, crv)\n-     val key: Option[String] = pubKey.getEncoded() match\n-       case b: Array[Byte] => Some(encodeToBase58(b))\n-       case null           => None\n-     (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n-       case _            => None\n-\n-  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n-\n-  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n-\n-  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n-\n-  def encodeToBase58(array: Array[Byte]): String =\n-    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n-      .unfold(\n-        BigInt(0.toByte +: array)\n-      )(n => if (n == 0) None else Some((n /% 58).swap))\n-      .map(_.toInt)\n-      .reverse\n-      .map(x => idxToChar(x))).mkString\n-\n-  def decodeFromBase58(b58: String): Array[Byte] = {\n-    val zeroCount = b58.takeWhile(_ == '1').length\n-    Array.fill(zeroCount)(0.toByte) ++\n-      b58\n-        .drop(zeroCount)\n-        .map(charToIdx)\n-        .toList\n-        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n-        .toByteArray\n-        .dropWhile(_ == 0.toByte)\n-  }\n-  def encodeB58(input: Seq[Byte]): String = {\n-     if (input.isEmpty) \"\"\n-     else {\n-       val big = new BigInteger(1, input.toArray)\n-       val builder = new StringBuilder\n-\n-       @tailrec\n-       def encode1(current: BigInteger): Unit = current match {\n-         case BigInteger.ZERO => ()\n-         case _ =>\n-           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n-           builder.append(alphabetBase58.charAt(remainder.intValue))\n-           encode1(x)\n-       }\n-       encode1(big)\n-       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n-       builder.toString().reverse\n-     }\n    }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697794557767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,9 +321,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def encrypt(key: PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n+  def encrypt(key: java.security.PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n     Try {\n       val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n       val iv     = new Array[Byte](IV_SIZE)\n       new java.security.SecureRandom().nextBytes(iv)\n"
                },
                {
                    "date": 1697795141727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -351,8 +351,10 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n+  def dec\n+\n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n      val algo = xyz.didx.Algorithm(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n"
                },
                {
                    "date": 1697795150617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -351,9 +351,9 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def dec\n+  def decrypt()\n \n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n      val algo = xyz.didx.Algorithm(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n"
                },
                {
                    "date": 1697795159140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -351,10 +351,22 @@\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n-  def decrypt()\n+  def decrypt(key: java.security.PrivateKey, ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, key, spec)\n \n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n   def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n      val algo = xyz.didx.Algorithm(kty, crv)\n      val key: Option[String] = pubKey.getEncoded() match\n        case b: Array[Byte] => Some(encodeToBase58(b))\n"
                },
                {
                    "date": 1697799972953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,8 +268,9 @@\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697799978573,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,9 +268,9 @@\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n-    ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800012124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -269,8 +269,9 @@\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n+    val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800031143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,8 +49,9 @@\n import javax.crypto.spec.GCMParameterSpec\n import java.util.Base64\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n import scala.annotation.tailrec\n+import org.bouncycastle.jce.spec.ECNamedCurveSpec\n \n \n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n"
                },
                {
                    "date": 1697800073155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -271,8 +271,9 @@\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    vc\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800078451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -271,9 +271,9 @@\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n-    vc\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800117367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,8 +272,9 @@\n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n+    pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800122840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,9 +272,9 @@\n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n-    pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800132614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -269,15 +269,23 @@\n     val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n+    // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n+    // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+    // Decode the base58 string into a byte array\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    // Create the key specification from the byte array\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n+    // Generate the public key\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697800138544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,9 @@\n import java.util.Base64\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n+import org.bouncycastle.jce.ECPointUtil\n \n \n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n"
                },
                {
                    "date": 1697800165350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n+import org.bouncycastle.jce.spec.ECPublicKeySpec\n \n \n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n"
                },
                {
                    "date": 1697800201159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -280,9 +280,8 @@\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Decode the base58 string into a byte array\n-    val keyBytes   = Crypto.decodeFromBase58(base58String)\n     // Create the key specification from the byte array\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n"
                },
                {
                    "date": 1697800209037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -275,8 +275,10 @@\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+\n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n"
                },
                {
                    "date": 1697800216928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,9 +278,9 @@\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), parseHexBinary(pubKey))\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Decode the base58 string into a byte array\n     // Create the key specification from the byte array\n"
                },
                {
                    "date": 1697800259570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,8 @@\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n-import org.bouncycastle.jce.spec.ECPublicKeySpec\n \n \n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n@@ -278,9 +277,9 @@\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Decode the base58 string into a byte array\n     // Create the key specification from the byte array\n"
                },
                {
                    "date": 1697800272352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n+import java.security.spec.ECPublicKeySpec\n \n \n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n"
                },
                {
                    "date": 1697800299087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,9 +281,8 @@\n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n-    // Decode the base58 string into a byte array\n     // Create the key specification from the byte array\n     val keySpec    = new X509EncodedKeySpec(keyBytes)\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n"
                },
                {
                    "date": 1697800304498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -275,8 +275,10 @@\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    // Decode the base58 string into a byte array\n+\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n"
                },
                {
                    "date": 1697800323325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -284,9 +284,9 @@\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697800341950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -288,9 +288,10 @@\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n-    IO(keyFactory.generatePublic(keySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+    IO(keyFactory.generatePublic(    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697800361789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -288,10 +288,9 @@\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n-    IO(keyFactory.generatePublic(    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n-).asInstanceOf[ECPublicKey].asRight[Exception])\n+    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697800882352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,9 +272,9 @@\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"secp160r2\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"Curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697800908841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,9 +272,9 @@\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"Curve25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697800923562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,11 +272,11 @@\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"ed25519\")\n     // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"secp160r2\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val  params = new ECNamedCurveSpec(\"ed255\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n \n"
                },
                {
                    "date": 1697801056773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,11 +272,11 @@\n     IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n \n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"ed25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"ed255\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val  params = new ECNamedCurveSpec(\"ed25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n \n"
                },
                {
                    "date": 1697801395260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -274,12 +274,13 @@\n   def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"ed25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(hexEncodedBytes))\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n"
                },
                {
                    "date": 1697801400537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,9 +278,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(hexEncodedBytes))\n+    val decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(hexEncodedBytes))\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n"
                },
                {
                    "date": 1697801428610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,10 +52,12 @@\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n import java.security.spec.ECPublicKeySpec\n+import javax.xml.bind.DatatypeConverter\n \n \n+\n object Crypto:\n   val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n   val IV_SIZE           = 12  // bytes\n   val TAG_SIZE          = 128 // bits\n"
                },
                {
                    "date": 1697801473165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -280,9 +280,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(hexEncodedBytes))\n+    val decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(keyBytes))\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n     // Create the public key specification from the public point and the named curve specification\n"
                },
                {
                    "date": 1697801488386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,9 +283,9 @@\n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n     val decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(keyBytes))\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), keyBytes)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697801775608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,8 @@\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n import java.security.spec.ECPublicKeySpec\n-import javax.xml.bind.DatatypeConverter\n \n \n \n object Crypto:\n"
                },
                {
                    "date": 1697801811368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -279,9 +279,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val decodedBytes: Array[Byte] = DatatypeConverter.parseHexBinary(new String(keyBytes))\n+    val decodedBytes: Array[Byte] = Base64.getDecoder.decode(hexString)(new String(keyBytes))\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n     // Create the public key specification from the public point and the named curve specification\n"
                },
                {
                    "date": 1697801819860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,441 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+import scala.annotation.tailrec\n+import org.bouncycastle.jce.spec.ECNamedCurveSpec\n+import org.bouncycastle.jce.ECPointUtil\n+import java.security.spec.ECPublicKeySpec\n+\n+\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+ \n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  \n+\n+  // store the private key keystore\n+ \n+\n+ \n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    // Create a new ECNamedCurveSpec\n+    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    // Decode the base58 string into a byte array\n+\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val decodedBytes: Array[Byte] = Base64.getDecoder.decode(new String(keyBytes))\n+\n+    // Decode the public point from the base58 string\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n+    // Create the public key specification from the public point and the named curve specification\n+    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+    // Create the key specification from the byte array\n+   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    // Create the key factory for the EC algorithm\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    // Generate the public key\n+    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def encrypt(key: java.security.PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, key, spec)\n+\n+      val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: java.security.PrivateKey, ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, key, spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n+     val algo = xyz.didx.Algorithm(kty, crv)\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n+  def encodeB58(input: Seq[Byte]): String = {\n+     if (input.isEmpty) \"\"\n+     else {\n+       val big = new BigInteger(1, input.toArray)\n+       val builder = new StringBuilder\n+\n+       @tailrec\n+       def encode1(current: BigInteger): Unit = current match {\n+         case BigInteger.ZERO => ()\n+         case _ =>\n+           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n+           builder.append(alphabetBase58.charAt(remainder.intValue))\n+           encode1(x)\n+       }\n+       encode1(big)\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n+       builder.toString().reverse\n+     }\n+   }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697803474935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -279,9 +279,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val decodedBytes: Array[Byte] = Base64.getDecoder.decode(new String(keyBytes))\n+    val decodedBytes: Array[Byte] = keyBytes))\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n     // Create the public key specification from the public point and the named curve specification\n@@ -437,446 +437,5 @@\n        encode1(big)\n        input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n        builder.toString().reverse\n      }\n-   }\n-package xyz.didx\n-\n-import java.security.KeyStore\n-import java.security.KeyPair\n-import java.security.KeyPairGenerator\n-import java.security.Key\n-\n-import cats.implicits._\n-import cats.effect.IO\n-\n-import java.security.KeyFactory\n-import java.security.spec.X509EncodedKeySpec\n-import java.security.KeyStore.TrustedCertificateEntry\n-import java.util.Base64\n-import java.security.PublicKey\n-import com.nimbusds.jose.*\n-import com.nimbusds.jose.crypto.*\n-import com.nimbusds.jose.jwk.*\n-import com.nimbusds.jose.jwk.gen.*\n-import com.nimbusds.jose.jwk.JWKSet\n-import java.nio.file.Paths\n-import java.io.FileOutputStream\n-import java.io.FileInputStream\n-import java.security.Security\n-import org.bouncycastle.jce.provider.BouncyCastleProvider\n-import java.security.cert.X509Certificate\n-import org.bouncycastle.asn1.x500.X500Name\n-import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n-import org.bouncycastle.cert.X509v3CertificateBuilder\n-import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n-import java.math.BigInteger\n-import java.util.Date\n-import java.security.interfaces.ECPrivateKey\n-import java.security.interfaces.ECPublicKey\n-import scala.util.Try\n-import scala.util.{Success, Failure}\n-import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n-import org.bouncycastle.crypto.params.ECPublicKeyParameters\n-import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n-import java.security.PrivateKey\n-import org.bouncycastle.crypto.digests.SHA256Digest\n-import org.bouncycastle.crypto.params.KDFParameters\n-import org.bouncycastle.jce.ECNamedCurveTable\n-import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n-import org.bouncycastle.crypto.params.ECDomainParameters\n-import org.bouncycastle.math.ec.ECPoint\n-import javax.crypto.Cipher\n-import javax.crypto.spec.SecretKeySpec\n-import javax.crypto.spec.GCMParameterSpec\n-import java.util.Base64\n-import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n-import scala.annotation.tailrec\n-import org.bouncycastle.jce.spec.ECNamedCurveSpec\n-import org.bouncycastle.jce.ECPointUtil\n-import java.security.spec.ECPublicKeySpec\n-\n-\n-\n-object Crypto:\n-  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n-  val IV_SIZE           = 12  // bytes\n-  val TAG_SIZE          = 128 // bits\n-\n-  Security.addProvider(new BouncyCastleProvider())\n-  // if the keystore file does not exist, create a new keystore file\n- \n-  // create a java keystore object\n-\n-  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      keyStore.load(null, password.toCharArray)\n-      val keystoreFile         = Paths.get(keystorePath).toFile\n-      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n-      keyStore.store(keystoreOutputStream, password.toCharArray)\n-      keystoreOutputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n-    val keyStore = KeyStore.getInstance(\"JKS\")\n-    Try {\n-      val keystoreFile        = Paths.get(keystorePath).toFile\n-      val keystoreInputStream = new FileInputStream(keystoreFile)\n-      keyStore.load(keystoreInputStream, password.toCharArray)\n-      keystoreInputStream.close()\n-    } match\n-      case Success(_)         => keyStore.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n-  }\n-\n-  // create a RSA key pair using java.security.KeyPairGenerator\n-  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n-    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-    keyPairGenerator.initialize(2048)\n-    Try {\n-      keyPairGenerator.generateKeyPair()\n-    } match\n-      case Success(keyPair)   => keyPair.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-  }\n-\n-  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n-      Try {\n-        keyPairGenerator.generateKeyPair()\n-      } match\n-        case Success(keyPair)   => keyPair.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n-\n-    }\n-\n-\n-  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n-  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new OctetKeyPairGenerator(Curve.Ed25519)\n-                 .keyID(alias)\n-                 .generate()\n-\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n-\n-    } yield jwk\n-\n-  // create a EC P-384 key pair\n-  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n-    for {\n-      // keyStore <- getKeyStore(\"password\", keystorePath)\n-      jwk <- Try {\n-               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-\n-               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n-             } match\n-               case Success(jwk)       => IO(jwk.asRight[Error])\n-               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n-\n-    } yield jwk // .computeThumbprint().toString()\n-\n-  // save the JWKSet to a file\n-  \n-\n-  // store the private key keystore\n- \n-\n- \n-\n-  // get the private key from keystore\n-  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n-    Try {\n-      keyStore.getKey(alias, password.toCharArray())\n-    } match\n-      case Success(key)       => key.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n-  }\n-\n-  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-\n-    Try {\n-      val jweObject = JWEObject.parse(encryptedMessage)\n-      jweObject.decrypt(new ECDHDecrypter(privateKey))\n-      jweObject.getPayload().toString()\n-    } match\n-      case Success(message)   => message.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-\n-  }\n-\n-  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val o = new JWEObject(\n-        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n-          .keyID(publicKey.toString())\n-          .build(),\n-        new Payload(message)\n-      )\n-      o.encrypt(new ECDHEncrypter(publicKey))\n-      o.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    Try {\n-      val jwsObject = new JWSObject(\n-        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n-        new Payload(message)\n-      )\n-      jwsObject.sign(new ECDSASigner(privateKey))\n-      jwsObject.serialize()\n-    } match\n-      case Success(s)         => s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n-  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n-    val jwsObject = JWSObject.parse(message)\n-    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n-      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  }\n-\n-  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n-  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n-    val jweObject = JWEObject.parse(message)\n-    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n-      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n-  } */\n-\n-  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n-\n-  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n-    Try {\n-      Security.addProvider(new BouncyCastleProvider())\n-      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n-      keyPairGenerator.initialize(2048)\n-      val keyPair          = keyPairGenerator.generateKeyPair()\n-      val subject          = new X500Name(s\"CN=$alias\")\n-      val issuer           = subject\n-      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n-      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n-      val notAfter         =\n-        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n-      val pubKey        =\n-        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n-      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n-      val certBuilder   = new X509v3CertificateBuilder(\n-        issuer,\n-        serialNumber,\n-        notBefore,\n-        notAfter,\n-        subject,\n-        publicKeyInfo\n-      )\n-      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n-      val certHolder    = certBuilder.build(contentSigner)\n-      val certConverter = JcaX509CertificateConverter()\n-      certConverter.getCertificate(certHolder)\n-    } match\n-      case Success(certificate) => certificate.asRight[Error]\n-      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n-  }\n-\n-  def storeCertificate(\n-    keyStore: KeyStore,\n-    certificate: X509Certificate,\n-    alias: String,\n-    password: Array[Char]\n-  ): IO[Either[Error, Unit]] =\n-    IO {\n-      Try {\n-        keyStore.setCertificateEntry(alias, certificate)\n-      } match\n-        case Success(_)         => ().asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n-    }\n-    // Save the keystore to a file or perform any other necessary operations\n-\n-  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n-    val keyBytes   = Base64.getDecoder.decode(base64String)\n-    val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n-    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n-\n-  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n-    // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n-    // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n-    // Decode the base58 string into a byte array\n-\n-    val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val decodedBytes: Array[Byte] = Base64.getDecoder.decode(hexString)(new String(keyBytes))\n-\n-    // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n-    // Create the public key specification from the public point and the named curve specification\n-    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n-    // Create the key specification from the byte array\n-   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    // Create the key factory for the EC algorithm\n-    val keyFactory = KeyFactory.getInstance(\"EC\")\n-    // Generate the public key\n-    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-\n-  def computeSharedSecret(\n-    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n-    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n-    nonce: Array[Byte]\n-  ): IO[Either[Error, Array[Byte]]] =\n-    IO {\n-      Try {\n-        val agreement        = new ECDHBasicAgreement()\n-        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n-        val domainParams     =\n-          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n-        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n-        agreement.init(privateKeyParams)\n-\n-        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n-        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n-\n-        // Convert shared secret to bytes\n-        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n-\n-        // Derive AES key using KDF (with nonce/salt)\n-        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n-        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n-\n-        val aesKey = new Array[Byte](32) // For AES-256\n-        kdf.generateBytes(aesKey, 0, aesKey.length)\n-        aesKey\n-      } match\n-        case Success(s)         => s.asRight[Error]\n-        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n-    }\n-\n-  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val iv     = new Array[Byte](IV_SIZE)\n-      new java.security.SecureRandom().nextBytes(iv)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n-      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n-      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def encrypt(key: java.security.PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val iv     = new Array[Byte](IV_SIZE)\n-      new java.security.SecureRandom().nextBytes(iv)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n-      cipher.init(Cipher.ENCRYPT_MODE, key, spec)\n-\n-      val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n-      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n-      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n-\n-      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n-      new String(decrypted, \"UTF-8\")\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def decrypt(key: java.security.PrivateKey, ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n-    Try {\n-      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n-      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n-      cipher.init(Cipher.DECRYPT_MODE, key, spec)\n-\n-      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n-      new String(decrypted, \"UTF-8\")\n-    } match {\n-      case Success(value)     => Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n-    }\n-  }\n-\n-  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n-     val algo = xyz.didx.Algorithm(kty, crv)\n-     val key: Option[String] = pubKey.getEncoded() match\n-       case b: Array[Byte] => Some(encodeToBase58(b))\n-       case null           => None\n-     (algo, key) match\n-       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n-       case _            => None\n-\n-  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n-\n-  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n-\n-  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n-\n-  def encodeToBase58(array: Array[Byte]): String =\n-    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n-      .unfold(\n-        BigInt(0.toByte +: array)\n-      )(n => if (n == 0) None else Some((n /% 58).swap))\n-      .map(_.toInt)\n-      .reverse\n-      .map(x => idxToChar(x))).mkString\n-\n-  def decodeFromBase58(b58: String): Array[Byte] = {\n-    val zeroCount = b58.takeWhile(_ == '1').length\n-    Array.fill(zeroCount)(0.toByte) ++\n-      b58\n-        .drop(zeroCount)\n-        .map(charToIdx)\n-        .toList\n-        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n-        .toByteArray\n-        .dropWhile(_ == 0.toByte)\n-  }\n-  def encodeB58(input: Seq[Byte]): String = {\n-     if (input.isEmpty) \"\"\n-     else {\n-       val big = new BigInteger(1, input.toArray)\n-       val builder = new StringBuilder\n-\n-       @tailrec\n-       def encode1(current: BigInteger): Unit = current match {\n-         case BigInteger.ZERO => ()\n-         case _ =>\n-           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n-           builder.append(alphabetBase58.charAt(remainder.intValue))\n-           encode1(x)\n-       }\n-       encode1(big)\n-       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n-       builder.toString().reverse\n-     }\n    }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1697805341115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -279,9 +279,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n     val keyBytes   = Crypto.decodeFromBase58(base58String)\n-    val decodedBytes: Array[Byte] = keyBytes))\n+    val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n     // Create the public key specification from the public point and the named curve specification\n@@ -291,9 +291,29 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    // Create a new ECNamedCurveSpec\n+    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    // Decode the base58 string into a byte array\n \n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val decodedBytes: Array[Byte] = keyBytes\n+\n+    // Decode the public point from the base58 string\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n+    // Create the public key specification from the public point and the named curve specification\n+    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+    // Create the key specification from the byte array\n+   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    // Create the key factory for the EC algorithm\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    // Generate the public key\n+    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1697805348026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,9 +291,9 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n"
                },
                {
                    "date": 1697805355908,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,9 +291,9 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+  def getECPublicKey(base58String: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n"
                },
                {
                    "date": 1697805379548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,9 +291,9 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-  def getECPublicKey(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+  def getECPublicKey(: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n"
                },
                {
                    "date": 1697805393935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,16 +291,16 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n-  def getECPublicKey(: String): IO[Either[Exception, ECPublicKey]] =\n+  def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n-    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val keyBytes   = Crypto.decodeFromBase58(key)\n     val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n"
                },
                {
                    "date": 1697805409834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -298,9 +298,9 @@\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n-    val keyBytes   = Crypto.decodeFromBase58(key)\n+   // val keyBytes   = Crypto.decodeFromBase58(key)\n     val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n"
                },
                {
                    "date": 1697805429359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -299,9 +299,9 @@\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n    // val keyBytes   = Crypto.decodeFromBase58(key)\n-    val decodedBytes: Array[Byte] = keyBytes\n+   // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n     val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n     // Create the public key specification from the public point and the named curve specification\n"
                },
                {
                    "date": 1697805453368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805922426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805929964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Basekey)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805936172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Basekey)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.key)\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805958788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.key)\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder())\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805967314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder())\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder().decode(key)))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697805973992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder().decode(key)))\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder().decode(key))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697806078546,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,9 +293,9 @@\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697806103811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,11 +293,11 @@\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"Ed25519\")\n     // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val  params = new ECNamedCurveSpec(\"25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n"
                },
                {
                    "date": 1697806165035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,9 @@\n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"Ed25519\")\n     // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n"
                },
                {
                    "date": 1697807215261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -293,9 +293,9 @@\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"Ed25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697808760016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,8 +291,10 @@\n     // Create the key factory for the EC algorithm\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n+    \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n"
                },
                {
                    "date": 1697808930564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,12 +292,12 @@\n     val keyFactory = KeyFactory.getInstance(\"EC\")\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n-    \n+\n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = //ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697808937149,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = //ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = new ECGenParameterSpec(name)//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697808946900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = new ECGenParameterSpec(name)//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = new ECGenParameterSpec(\"name\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697808953806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = new ECGenParameterSpec(\"name\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = new ECGenParameterSpec(\"curve2\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697808968337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n import scala.annotation.tailrec\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n import java.security.spec.ECPublicKeySpec\n+import java.security.spec.ECGenParameterSpec\n \n \n \n object Crypto:\n@@ -295,9 +296,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = new ECGenParameterSpec(\"curve2\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = new ECGenParameterSpec(\"curve25519\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697809036863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,9 +296,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = new ECGenParameterSpec(\"curve25519\")//ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = nECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n"
                },
                {
                    "date": 1697809577391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,18 +296,18 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = nECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n     // Create a new ECNamedCurveSpec\n     val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n     // Decode the base58 string into a byte array\n \n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder().decode(key))\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.Base64.getUrlDecoder().decode(key))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697809587862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,9 +305,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.Base64.getUrlDecoder().decode(key))\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.getBytes()).getUrlDecoder().decode(key))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697809602453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,9 +305,9 @@\n    // val keyBytes   = Crypto.decodeFromBase58(key)\n    // val decodedBytes: Array[Byte] = keyBytes\n \n     // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.getBytes()).getUrlDecoder().decode(key))\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.getBytes()) //.getUrlDecoder().decode(key))\n     // Create the public key specification from the public point and the named curve specification\n     val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n     // Create the key specification from the byte array\n    // val keySpec    = new X509EncodedKeySpec(keyBytes)\n"
                },
                {
                    "date": 1697810847893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,25 +296,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n-    // Create a new ECNamedCurveSpec\n-    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n-    // Decode the base58 string into a byte array\n-\n-   // val keyBytes   = Crypto.decodeFromBase58(key)\n-   // val decodedBytes: Array[Byte] = keyBytes\n-\n-    // Decode the public point from the base58 string\n-    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), key.getBytes()) //.getUrlDecoder().decode(key))\n-    // Create the public key specification from the public point and the named curve specification\n-    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n-    // Create the key specification from the byte array\n-   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n-    // Create the key factory for the EC algorithm\n-    val keyFactory = KeyFactory.getInstance(\"EC\")\n-    // Generate the public key\n+    \n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697810894345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,10 +296,11 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    \n-    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+    val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n+    val publicKeySpec = new X509EncodedKeySpec(publicKeyBytes)\n+    IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697810917904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -297,9 +297,9 @@\n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    val publicKeySpec = new X509EncodedKeySpec(publicKeyBytes)\n+    val publicKeySpec = new X509EncodedKeySpec(Nase64)\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697810973687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -297,9 +297,9 @@\n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    val publicKeySpec = new X509EncodedKeySpec(Nase64)\n+    val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder)\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697810983729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -297,9 +297,9 @@\n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder)\n+    val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697811418253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,8 +295,9 @@\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n+    \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697811459517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,9 +295,10 @@\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n-    \n+    val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n"
                },
                {
                    "date": 1697811476908,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n import org.bouncycastle.jce.spec.ECNamedCurveSpec\n import org.bouncycastle.jce.ECPointUtil\n import java.security.spec.ECPublicKeySpec\n import java.security.spec.ECGenParameterSpec\n+import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\n \n \n \n object Crypto:\n"
                },
                {
                    "date": 1697811516049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -297,8 +297,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n"
                },
                {
                    "date": 1697811556935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,8 +54,9 @@\n import org.bouncycastle.jce.ECPointUtil\n import java.security.spec.ECPublicKeySpec\n import java.security.spec.ECGenParameterSpec\n import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\n+import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory\n \n \n \n object Crypto:\n@@ -297,9 +298,9 @@\n \n \n   def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n     val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n+    val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n"
                },
                {
                    "date": 1697811636136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n     val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    val publicKeySpec = new X509EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n+    val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1697811750215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -303,9 +303,9 @@\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n-    IO(keyFactory.generatePublic(publicKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+    IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1697811768057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,9 +296,9 @@\n     // Generate the public key\n     IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n \n \n-  def getECPublicKey(key: String): IO[Either[Exception, ECPublicKey]] =\n+  def getECPublicKey(key: String) =\n     val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1697812604253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,10 @@\n \n       val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n       (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n     } match {\n-      case Success(value)     => Right(value)\n+      case Success(value)     => \n+        Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n \n"
                },
                {
                    "date": 1697812620736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,8 +365,9 @@\n       val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n       (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n     } match {\n       case Success(value)     => \n+        \n         Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n"
                },
                {
                    "date": 1697812627971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,9 +365,9 @@\n       val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n       (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n     } match {\n       case Success(value)     => \n-        \n+        pr\n         Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n"
                },
                {
                    "date": 1697812634239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,9 +365,9 @@\n       val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n       (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n     } match {\n       case Success(value)     => \n-        pr\n+        prin\n         Right(value)\n       case Failure(exception) => Left(Error(exception.getMessage))\n     }\n   }\n"
                },
                {
                    "date": 1697812653402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -367,9 +367,10 @@\n     } match {\n       case Success(value)     => \n         println(s\"Encrypted: ${value}\")\n         Right(value)\n-      case Failure(exception) => Left(Error(exception.getMessage))\n+      case Failure(exception) => \n+        Left(Error(exception.getMessage))\n     }\n   }\n \n   def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1697812669573,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,458 @@\n+package xyz.didx\n+\n+import java.security.KeyStore\n+import java.security.KeyPair\n+import java.security.KeyPairGenerator\n+import java.security.Key\n+\n+import cats.implicits._\n+import cats.effect.IO\n+\n+import java.security.KeyFactory\n+import java.security.spec.X509EncodedKeySpec\n+import java.security.KeyStore.TrustedCertificateEntry\n+import java.util.Base64\n+import java.security.PublicKey\n+import com.nimbusds.jose.*\n+import com.nimbusds.jose.crypto.*\n+import com.nimbusds.jose.jwk.*\n+import com.nimbusds.jose.jwk.gen.*\n+import com.nimbusds.jose.jwk.JWKSet\n+import java.nio.file.Paths\n+import java.io.FileOutputStream\n+import java.io.FileInputStream\n+import java.security.Security\n+import org.bouncycastle.jce.provider.BouncyCastleProvider\n+import java.security.cert.X509Certificate\n+import org.bouncycastle.asn1.x500.X500Name\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\n+import org.bouncycastle.cert.X509v3CertificateBuilder\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\n+import java.math.BigInteger\n+import java.util.Date\n+import java.security.interfaces.ECPrivateKey\n+import java.security.interfaces.ECPublicKey\n+import scala.util.Try\n+import scala.util.{Success, Failure}\n+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters\n+import org.bouncycastle.crypto.generators.KDF2BytesGenerator\n+import java.security.PrivateKey\n+import org.bouncycastle.crypto.digests.SHA256Digest\n+import org.bouncycastle.crypto.params.KDFParameters\n+import org.bouncycastle.jce.ECNamedCurveTable\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters\n+import org.bouncycastle.crypto.params.ECDomainParameters\n+import org.bouncycastle.math.ec.ECPoint\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n+import javax.crypto.spec.GCMParameterSpec\n+import java.util.Base64\n+import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\n+import scala.annotation.tailrec\n+import org.bouncycastle.jce.spec.ECNamedCurveSpec\n+import org.bouncycastle.jce.ECPointUtil\n+import java.security.spec.ECPublicKeySpec\n+import java.security.spec.ECGenParameterSpec\n+import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\n+import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory\n+\n+\n+\n+object Crypto:\n+  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n+  val IV_SIZE           = 12  // bytes\n+  val TAG_SIZE          = 128 // bits\n+\n+  Security.addProvider(new BouncyCastleProvider())\n+  // if the keystore file does not exist, create a new keystore file\n+ \n+  // create a java keystore object\n+\n+  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      keyStore.load(null, password.toCharArray)\n+      val keystoreFile         = Paths.get(keystorePath).toFile\n+      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n+      keyStore.store(keystoreOutputStream, password.toCharArray)\n+      keystoreOutputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n+    val keyStore = KeyStore.getInstance(\"JKS\")\n+    Try {\n+      val keystoreFile        = Paths.get(keystorePath).toFile\n+      val keystoreInputStream = new FileInputStream(keystoreFile)\n+      keyStore.load(keystoreInputStream, password.toCharArray)\n+      keystoreInputStream.close()\n+    } match\n+      case Success(_)         => keyStore.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n+  }\n+\n+  // create a RSA key pair using java.security.KeyPairGenerator\n+  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n+    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+    keyPairGenerator.initialize(2048)\n+    Try {\n+      keyPairGenerator.generateKeyPair()\n+    } match\n+      case Success(keyPair)   => keyPair.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+  }\n+\n+  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n+      Try {\n+        keyPairGenerator.generateKeyPair()\n+      } match\n+        case Success(keyPair)   => keyPair.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n+\n+    }\n+\n+\n+  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n+  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new OctetKeyPairGenerator(Curve.Ed25519)\n+                 .keyID(alias)\n+                 .generate()\n+\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n+\n+    } yield jwk\n+\n+  // create a EC P-384 key pair\n+  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n+    for {\n+      // keyStore <- getKeyStore(\"password\", keystorePath)\n+      jwk <- Try {\n+               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+\n+               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n+             } match\n+               case Success(jwk)       => IO(jwk.asRight[Error])\n+               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n+\n+    } yield jwk // .computeThumbprint().toString()\n+\n+  // save the JWKSet to a file\n+  \n+\n+  // store the private key keystore\n+ \n+\n+ \n+\n+  // get the private key from keystore\n+  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n+    Try {\n+      keyStore.getKey(alias, password.toCharArray())\n+    } match\n+      case Success(key)       => key.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n+  }\n+\n+  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+\n+    Try {\n+      val jweObject = JWEObject.parse(encryptedMessage)\n+      jweObject.decrypt(new ECDHDecrypter(privateKey))\n+      jweObject.getPayload().toString()\n+    } match\n+      case Success(message)   => message.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+\n+  }\n+\n+  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val o = new JWEObject(\n+        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n+          .keyID(publicKey.toString())\n+          .build(),\n+        new Payload(message)\n+      )\n+      o.encrypt(new ECDHEncrypter(publicKey))\n+      o.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n+  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    Try {\n+      val jwsObject = new JWSObject(\n+        new JWSHeader.Builder(JWSAlgorithm.ES384).keyID(privateKey.toString()).build(),\n+        new Payload(message)\n+      )\n+      jwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.serialize()\n+    } match\n+      case Success(s)         => s.asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n+  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n+    val jwsObject = JWSObject.parse(message)\n+    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n+      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  }\n+\n+  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n+  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+    val jweObject = JWEObject.parse(message)\n+    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n+      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n+      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+  } */\n+\n+  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n+\n+  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n+    Try {\n+      Security.addProvider(new BouncyCastleProvider())\n+      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n+      keyPairGenerator.initialize(2048)\n+      val keyPair          = keyPairGenerator.generateKeyPair()\n+      val subject          = new X500Name(s\"CN=$alias\")\n+      val issuer           = subject\n+      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n+      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n+      val notAfter         =\n+        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n+      val pubKey        =\n+        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n+      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n+      val certBuilder   = new X509v3CertificateBuilder(\n+        issuer,\n+        serialNumber,\n+        notBefore,\n+        notAfter,\n+        subject,\n+        publicKeyInfo\n+      )\n+      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n+      val certHolder    = certBuilder.build(contentSigner)\n+      val certConverter = JcaX509CertificateConverter()\n+      certConverter.getCertificate(certHolder)\n+    } match\n+      case Success(certificate) => certificate.asRight[Error]\n+      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n+  }\n+\n+  def storeCertificate(\n+    keyStore: KeyStore,\n+    certificate: X509Certificate,\n+    alias: String,\n+    password: Array[Char]\n+  ): IO[Either[Error, Unit]] =\n+    IO {\n+      Try {\n+        keyStore.setCertificateEntry(alias, certificate)\n+      } match\n+        case Success(_)         => ().asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n+    }\n+    // Save the keystore to a file or perform any other necessary operations\n+\n+  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n+    val keyBytes   = Base64.getDecoder.decode(base64String)\n+    val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n+    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n+\n+  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n+    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n+    // Create a new ECNamedCurveSpec\n+    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n+    // Decode the base58 string into a byte array\n+\n+    val keyBytes   = Crypto.decodeFromBase58(base58String)\n+    val decodedBytes: Array[Byte] = keyBytes\n+\n+    // Decode the public point from the base58 string\n+    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n+    // Create the public key specification from the public point and the named curve specification\n+    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n+    // Create the key specification from the byte array\n+   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n+    // Create the key factory for the EC algorithm\n+    val keyFactory = KeyFactory.getInstance(\"EC\")\n+    // Generate the public key\n+    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n+\n+\n+  def getECPublicKey(key: String) =\n+    val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+    val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n+\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n+    val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n+    val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+    IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n+\n+  def computeSharedSecret(\n+    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n+    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n+    nonce: Array[Byte]\n+  ): IO[Either[Error, Array[Byte]]] =\n+    IO {\n+      Try {\n+        val agreement        = new ECDHBasicAgreement()\n+        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n+        val domainParams     =\n+          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n+        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n+        agreement.init(privateKeyParams)\n+\n+        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n+        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n+\n+        // Convert shared secret to bytes\n+        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n+\n+        // Derive AES key using KDF (with nonce/salt)\n+        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n+        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n+\n+        val aesKey = new Array[Byte](32) // For AES-256\n+        kdf.generateBytes(aesKey, 0, aesKey.length)\n+        aesKey\n+      } match\n+        case Success(s)         => s.asRight[Error]\n+        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n+    }\n+\n+  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def encrypt(key: java.security.PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val iv     = new Array[Byte](IV_SIZE)\n+      new java.security.SecureRandom().nextBytes(iv)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n+      cipher.init(Cipher.ENCRYPT_MODE, key, spec)\n+\n+      val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n+      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n+    } match {\n+      case Success(value)     => \n+        println(s\"Encrypted: ${value}\")\n+        Right(value)\n+      case Failure(exception) => \n+        println\n+        Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def decrypt(key: java.security.PrivateKey, ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n+    Try {\n+      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n+      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n+      cipher.init(Cipher.DECRYPT_MODE, key, spec)\n+\n+      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n+      new String(decrypted, \"UTF-8\")\n+    } match {\n+      case Success(value)     => Right(value)\n+      case Failure(exception) => Left(Error(exception.getMessage))\n+    }\n+  }\n+\n+  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n+     val algo = xyz.didx.Algorithm(kty, crv)\n+     val key: Option[String] = pubKey.getEncoded() match\n+       case b: Array[Byte] => Some(encodeToBase58(b))\n+       case null           => None\n+     (algo, key) match\n+       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n+       case _            => None\n+\n+  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n+\n+  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n+\n+  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n+\n+  def encodeToBase58(array: Array[Byte]): String =\n+    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n+      .unfold(\n+        BigInt(0.toByte +: array)\n+      )(n => if (n == 0) None else Some((n /% 58).swap))\n+      .map(_.toInt)\n+      .reverse\n+      .map(x => idxToChar(x))).mkString\n+\n+  def decodeFromBase58(b58: String): Array[Byte] = {\n+    val zeroCount = b58.takeWhile(_ == '1').length\n+    Array.fill(zeroCount)(0.toByte) ++\n+      b58\n+        .drop(zeroCount)\n+        .map(charToIdx)\n+        .toList\n+        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n+        .toByteArray\n+        .dropWhile(_ == 0.toByte)\n+  }\n+  def encodeB58(input: Seq[Byte]): String = {\n+     if (input.isEmpty) \"\"\n+     else {\n+       val big = new BigInteger(1, input.toArray)\n+       val builder = new StringBuilder\n+\n+       @tailrec\n+       def encode1(current: BigInteger): Unit = current match {\n+         case BigInteger.ZERO => ()\n+         case _ =>\n+           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n+           builder.append(alphabetBase58.charAt(remainder.intValue))\n+           encode1(x)\n+       }\n+       encode1(big)\n+       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n+       builder.toString().reverse\n+     }\n+   }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1697451216279,
            "name": "Commit-0",
            "content": "import sttp.tapir.Schema"
        }
    ]
}