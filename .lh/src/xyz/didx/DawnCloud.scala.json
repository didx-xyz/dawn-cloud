{
    "sourceFile": "src/xyz/didx/DawnCloud.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 176,
            "patches": [
                {
                    "date": 1696858144415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1696858176522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n import com.monovore.decline.effect.*\n import io.circe.*\n import io.circe.parser.*\n import io.circe.syntax.*\n+import \n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n@@ -19,5 +20,5 @@\n       assertion,\n       capabilityDelegation,\n       capabilityInvocation\n     ).asJson.noSpaces\n-  }\n+  \n"
                },
                {
                    "date": 1696858183842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n import com.monovore.decline.effect.*\n import io.circe.*\n import io.circe.parser.*\n import io.circe.syntax.*\n-import \n+import didcomm.\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n"
                },
                {
                    "date": 1696858189891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n import com.monovore.decline.effect.*\n import io.circe.*\n import io.circe.parser.*\n import io.circe.syntax.*\n-import didcomm.\n+import didcomm.*\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n"
                },
                {
                    "date": 1696858244236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did, keyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: , keyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696858259108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: , keyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: KeyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925281365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: KeyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: KeyAgreementI, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925331669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: KeyAgreementI, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication; , assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925342923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,24 @@\n+package xyz.didx\n+\n+import cats.effect.*\n+import cats.syntax.all.*\n+import com.monovore.decline.*\n+import com.monovore.decline.effect.*\n+import io.circe.*\n+import io.circe.parser.*\n+import io.circe.syntax.*\n+import didcomm.*\n+\n+object DawnCloud:\n+\n+  // create a DIDDoc using DIDCodec\n+  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication; AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+    DIDDoc(\n+      did,\n+      keyAgreement,\n+      authentication,\n+      assertion,\n+      capabilityDelegation,\n+      capabilityInvocation\n+    ).asJson.noSpaces\n+  \n"
                },
                {
                    "date": 1696925348068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication; AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n@@ -21,28 +21,4 @@\n       capabilityDelegation,\n       capabilityInvocation\n     ).asJson.noSpaces\n   \n-package xyz.didx\n-\n-import cats.effect.*\n-import cats.syntax.all.*\n-import com.monovore.decline.*\n-import com.monovore.decline.effect.*\n-import io.circe.*\n-import io.circe.parser.*\n-import io.circe.syntax.*\n-import didcomm.*\n-\n-object DawnCloud:\n-\n-  // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication; , assertion, capabilityDelegation, capabilityInvocation) = \n-    DIDDoc(\n-      did,\n-      keyAgreement,\n-      authentication,\n-      assertion,\n-      capabilityDelegation,\n-      capabilityInvocation\n-    ).asJson.noSpaces\n-  \n"
                },
                {
                    "date": 1696925397536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: KeyAgreementInstance, authentication AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance, authentication: AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925402698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance, authentication: AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925410395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: AuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: SetAuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925417450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: SetAuthenticationInstance, assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion, capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1696925475971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion, capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion , capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1697111873368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,5 +20,7 @@\n       assertion,\n       capabilityDelegation,\n       capabilityInvocation\n     ).asJson.noSpaces\n+\n+    \n   \n"
                },
                {
                    "date": 1697111882396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,6 +21,6 @@\n       capabilityDelegation,\n       capabilityInvocation\n     ).asJson.noSpaces\n \n-    \n+  // write to IPFS\n   \n"
                },
                {
                    "date": 1697111892313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,5 +22,7 @@\n       capabilityInvocation\n     ).asJson.noSpaces\n \n   // write to IPFS\n+  def writeIPFS(didDoc: String) = \n+    val ipfs = new IPFS(\"/ip4/\n   \n"
                },
                {
                    "date": 1697112279688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,6 +23,5 @@\n     ).asJson.noSpaces\n \n   // write to IPFS\n   def writeIPFS(didDoc: String) = \n-    val ipfs = new IPFS(\"/ip4/\n   \n"
                },
                {
                    "date": 1697112369324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,11 @@\n import io.circe.*\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n+import io.ipfs.api.{IPFS, MerkleNode}\n \n+\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion , capabilityDelegation, capabilityInvocation) = \n"
                },
                {
                    "date": 1697112388147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,5 +25,17 @@\n     ).asJson.noSpaces\n \n   // write to IPFS\n   def writeIPFS(didDoc: String) = \n+    def writeIPFS(didDoc: String): Unit = {\n+      val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n+\n+      val json = didDoc.asJson.noSpaces\n+\n+      val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+\n+      future.thenAccept(node => {\n+        val cid = node.hash.toBase58\n+        println(s\"DIDDoc written to IPFS with CID: $cid\")\n+      })\n+    }\n   \n"
                },
                {
                    "date": 1697112398728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,18 +24,17 @@\n       capabilityInvocation\n     ).asJson.noSpaces\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String) = \n-    def writeIPFS(didDoc: String): Unit = {\n-      val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n+  def writeIPFS(didDoc: String): Unit = {\n+    val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n-      val json = didDoc.asJson.noSpaces\n+    val json = didDoc.asJson.noSpaces\n \n-      val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+    val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n-      future.thenAccept(node => {\n-        val cid = node.hash.toBase58\n-        println(s\"DIDDoc written to IPFS with CID: $cid\")\n-      })\n-    }\n+    future.thenAccept(node => {\n+      val cid = node.hash.toBase58\n+      println(s\"DIDDoc written to IPFS with CID: $cid\")\n+    })\n+  }\n   \n"
                },
                {
                    "date": 1697112470678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion , capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: , capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1697112478814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: , capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: Set[Ass], capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1697112488010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: Set[Ass], capabilityDelegation, capabilityInvocation) = \n+  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: Set[AssertionInstance], capabilityDelegation, capabilityInvocation) = \n     DIDDoc(\n       did,\n       keyAgreement,\n       authentication,\n"
                },
                {
                    "date": 1697113537699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,17 +13,26 @@\n \n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n-  def makeDIDDoc(did: String, keyAgreement: Set[KeyAgreementInstance], authentication: Set[AuthenticationInstance], assertion: Set[AssertionInstance], capabilityDelegation, capabilityInvocation) = \n-    DIDDoc(\n-      did,\n-      keyAgreement,\n-      authentication,\n-      assertion,\n-      capabilityDelegation,\n-      capabilityInvocation\n-    ).asJson.noSpaces\n+  def createDIDDocument(\n+       did: String,\n+       controller: String,\n+       verificationMethod: VerificationMethod,\n+       service: Service\n+   ): DIDDoc =\n+     DIDDoc(\n+       did,\n+       Some(controller),\n+       None,\n+       Some(Set(verificationMethod)),\n+       None,\n+       None,\n+       None,\n+       None,\n+       None,\n+       Some(Set(service))\n+     )\n \n   // write to IPFS\n   def writeIPFS(didDoc: String): Unit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n"
                },
                {
                    "date": 1697182684487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): Unit = {\n+  def writeIPFS(didDoc: String): IOUnit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182690390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IOUnit = {\n+  def writeIPFS(didDoc: String): IO[EitherUnit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182698516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[EitherUnit = {\n+  def writeIPFS(didDoc: String): IO[Either[Unit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182705979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Unit = {\n+  def writeIPFS(didDoc: String): IO[Either[Error]Unit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182713139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error]Unit = {\n+  def writeIPFS(didDoc: String): IO[Either[ErrorUnit = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182719047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n        Some(Set(service))\n      )\n \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[ErrorUnit = {\n+  def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n"
                },
                {
                    "date": 1697182726936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,10 +8,12 @@\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n+import monix.catnap.FutureLift\n \n \n+\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n"
                },
                {
                    "date": 1697182742427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,9 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+    \n \n     future.thenAccept(node => {\n       val cid = node.hash.toBase58\n       println(s\"DIDDoc written to IPFS with CID: $cid\")\n"
                },
                {
                    "date": 1697182748450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n-    \n+    val lift = FutureLift[IO].lift(future)\n \n     future.thenAccept(node => {\n       val cid = node.hash.toBase58\n       println(s\"DIDDoc written to IPFS with CID: $cid\")\n"
                },
                {
                    "date": 1697182781104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n import monix.catnap.FutureLift\n \n \n \n+\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n"
                },
                {
                    "date": 1697182788584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,12 @@\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n import monix.catnap.FutureLift\n+import java.util\n \n \n \n-\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n"
                },
                {
                    "date": 1697182794387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n import monix.catnap.FutureLift\n-import java.util\n+import java.util.Com\n \n \n \n object DawnCloud:\n"
                },
                {
                    "date": 1697182810868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,13 @@\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n import monix.catnap.FutureLift\n-import java.util.Com\n+import java.util.concurrentCompletableFuture\n \n \n \n+\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n"
                },
                {
                    "date": 1697182929945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,10 +8,11 @@\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n+\n import monix.catnap.FutureLift\n-import java.util.concurrentCompletableFuture\n+import java.util.concurrent.CompletableFuture\n \n \n \n \n"
                },
                {
                    "date": 1697183062427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n-\n+import monix.eval.Task\n import monix.catnap.FutureLift\n import java.util.concurrent.CompletableFuture\n \n \n@@ -37,8 +37,9 @@\n        None,\n        Some(Set(service))\n      )\n \n+     \n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n"
                },
                {
                    "date": 1697183099232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n-import monix.eval.Task\n import monix.catnap.FutureLift\n import java.util.concurrent.CompletableFuture\n \n \n@@ -37,9 +36,19 @@\n        None,\n        Some(Set(service))\n      )\n \n-     \n+  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[A] = {\n+    IO.async { callback =>\n+      cf.handle[Unit] { (result: A, err: Throwable) =>\n+        if (err != null) {\n+          callback(Left(err))\n+        } else {\n+          callback(Right(result))\n+        }\n+      }\n+    }\n+  }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n"
                },
                {
                    "date": 1697183204319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n-import monix.catnap.FutureLift\n import java.util.concurrent.CompletableFuture\n \n \n \n@@ -54,9 +53,8 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n-    val lift = FutureLift[IO].lift(future)\n \n     future.thenAccept(node => {\n       val cid = node.hash.toBase58\n       println(s\"DIDDoc written to IPFS with CID: $cid\")\n"
                },
                {
                    "date": 1697183216626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,10 +54,7 @@\n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n-    future.thenAccept(node => {\n-      val cid = node.hash.toBase58\n-      println(s\"DIDDoc written to IPFS with CID: $cid\")\n     })\n   }\n   \n"
                },
                {
                    "date": 1697183264148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n-    val future: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+    val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n \n     })\n   }\n   \n"
                },
                {
                    "date": 1697183304770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,6 +55,6 @@\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n \n     })\n-  }\n   \n+  \n"
                },
                {
                    "date": 1697183316901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,7 +54,7 @@\n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n \n-    })\n+    }\n   \n   \n"
                },
                {
                    "date": 1697183333587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n+    \n \n     }\n   \n   \n"
                },
                {
                    "date": 1697183342947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n-    \n+    val io: IO[MerkleNode] = fromCompletableFuture(future)\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697183388440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n        None,\n        Some(Set(service))\n      )\n \n-  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[A] = {\n+  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[EitherA] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n         if (err != null) {\n           callback(Left(err))\n"
                },
                {
                    "date": 1697183400152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n        None,\n        Some(Set(service))\n      )\n \n-  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[EitherA] = {\n+  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n         if (err != null) {\n           callback(Left(err))\n"
                },
                {
                    "date": 1697183411446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,14 +38,9 @@\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n-        if (err != null) {\n-          callback(Left(err))\n-        } else {\n-          callback(Right(result))\n-        }\n-      }\n+       \n     }\n   }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n"
                },
                {
                    "date": 1697183417011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,11 @@\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n-       \n+        if (err != null) callback(Left(err))\n+        else callback(Right(result))\n+      }\n     }\n   }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n"
                },
                {
                    "date": 1697183453233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n import cats.effect.*\n import cats.syntax.all.*\n import com.monovore.decline.*\n import com.monovore.decline.effect.*\n-import io.circe.*\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.{IPFS, MerkleNode}\n"
                },
                {
                    "date": 1697183513994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,10 +37,9 @@\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n-        if (err != null) callback(Left(err))\n-        else callback(Right(result))\n+       \n       }\n     }\n   }\n   // write to IPFS\n"
                },
                {
                    "date": 1697184441036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,9 @@\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n+        \n        \n       }\n     }\n   }\n"
                },
                {
                    "date": 1697184468288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,10 @@\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n       cf.handle[Unit] { (result: A, err: Throwable) =>\n-        \n+        if (err != null) callback(Left(err))\n+        else callback(Right(result))\n        \n       }\n     }\n   }\n"
                },
                {
                    "date": 1697184596989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,11 +36,9 @@\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n-      cf.handle[Unit] { (result: A, err: Throwable) =>\n-        if (err != null) callback(Left(err))\n-        else callback(Right(result))\n+      cf.handle[Unit] { (result: A, err: Throwable)\n        \n       }\n     }\n   }\n"
                },
                {
                    "date": 1697184619271,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,12 @@\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n-      cf.handle[Unit] { (result: A, err: Throwable)\n+      cf.handle[Unit] { (result: A, err: Throwable) match\n+        case (null, err) => callback(Left(err))\n+        case (result, null) => callback(Right(result))\n+        case _ => callback(Left(new Exception(\"Unexpected error\")))\n        \n       }\n     }\n   }\n"
                },
                {
                    "date": 1697184651485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,12 +36,11 @@\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n     IO.async { callback =>\n-      cf.handle[Unit] { (result: A, err: Throwable) match\n-        case (null, err) => callback(Left(err))\n-        case (result, null) => callback(Right(result))\n-        case _ => callback(Left(new Exception(\"Unexpected error\")))\n+      cf.handle[Unit] { (result: A, err: Throwable) =>\n+        if (err != null) callback(Left(err))\n+        else callback(Right(result))\n        \n       }\n     }\n   }\n"
                },
                {
                    "date": 1697184756763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,7 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n-    val io: IO[MerkleNode] = fromCompletableFuture(future)\n-\n     }\n   \n   \n"
                },
                {
                    "date": 1697184763835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,7 +50,8 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n+    val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n     }\n   \n   \n"
                },
                {
                    "date": 1697184793143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n+    \n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n     }\n"
                },
                {
                    "date": 1697184801514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    \n+    val ns \n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n     }\n"
                },
                {
                    "date": 1697184829001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,10 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    val ns \n+    \n+    val ns = ipfs.name.publish(json)\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n     }\n"
                },
                {
                    "date": 1697184838191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    \n+    val mh = ipfs.add(json)\n     val ns = ipfs.name.publish(json)\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n"
                },
                {
                    "date": 1697184860212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n+    \n     val mh = ipfs.add(json)\n     val ns = ipfs.name.publish(json)\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n"
                },
                {
                    "date": 1697184879649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,10 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    \n-    val mh = ipfs.add(json)\n+\n     val ns = ipfs.name.publish(json)\n \n     val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n"
                },
                {
                    "date": 1697184891588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n \n     val ns = ipfs.name.publish(json)\n \n-    val future: CompletableFuture[MerkleNode] = ipfs.add(json)\n+    val future: CompletableFuture[MerkleNode] = ipfs.add(ns)\n     val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n     }\n   \n   \n"
                },
                {
                    "date": 1697184994727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,11 +49,8 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n-    val ns = ipfs.name.publish(json)\n-\n-    val future: CompletableFuture[MerkleNode] = ipfs.add(ns)\n-    val result: IO[Either[Error,MerkleNode]] = fromCompletableFuture(future)\n+  \n     }\n   \n   \n"
                },
                {
                    "date": 1697185008962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,8 +49,8 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n \n-  \n+    val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n     }\n   \n   \n"
                },
                {
                    "date": 1697185071419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,7 +50,9 @@\n \n     val json = didDoc.asJson.noSpaces\n \n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+    IO.fromCompletableFuture(cf).map(_ => Right(()))\n+\n     }\n   \n   \n"
                },
                {
                    "date": 1697185115234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+package xyz.didx\n+\n+import cats.effect.*\n+import cats.syntax.all.*\n+import com.monovore.decline.*\n+import com.monovore.decline.effect.*\n+import io.circe.parser.*\n+import io.circe.syntax.*\n+import didcomm.*\n+import io.ipfs.api.{IPFS, MerkleNode}\n+import java.util.concurrent.CompletableFuture\n+\n+\n+\n+\n+object DawnCloud:\n+\n+  // create a DIDDoc using DIDCodec\n+  def createDIDDocument(\n+       did: String,\n+       controller: String,\n+       verificationMethod: VerificationMethod,\n+       service: Service\n+   ): DIDDoc =\n+     DIDDoc(\n+       did,\n+       Some(controller),\n+       None,\n+       Some(Set(verificationMethod)),\n+       None,\n+       None,\n+       None,\n+       None,\n+       None,\n+       Some(Set(service))\n+     )\n+\n+  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n+    IO.async { callback =>\n+      cf.handle[Unit] { (result: A, err: Throwable) =>\n+        if (err != null) callback(Left(err))\n+        else callback(Right(result))\n+       \n+      }\n+    }\n+  }\n+  // write to IPFS\n+  def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n+    val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n+\n+    val json = didDoc.asJson.noSpaces\n+\n+    IO.fromCompletableFuture(cf).map(_ => Right(()))\n+\n+    }\n+  \n+  \n"
                },
                {
                    "date": 1697185147744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,68 +48,11 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n+    val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n     IO.fromCompletableFuture(cf).map(_ => Right(()))\n \n     }\n   \n   \n-package xyz.didx\n-\n-import cats.effect.*\n-import cats.syntax.all.*\n-import com.monovore.decline.*\n-import com.monovore.decline.effect.*\n-import io.circe.parser.*\n-import io.circe.syntax.*\n-import didcomm.*\n-import io.ipfs.api.{IPFS, MerkleNode}\n-import java.util.concurrent.CompletableFuture\n-\n-\n-\n-\n-object DawnCloud:\n-\n-  // create a DIDDoc using DIDCodec\n-  def createDIDDocument(\n-       did: String,\n-       controller: String,\n-       verificationMethod: VerificationMethod,\n-       service: Service\n-   ): DIDDoc =\n-     DIDDoc(\n-       did,\n-       Some(controller),\n-       None,\n-       Some(Set(verificationMethod)),\n-       None,\n-       None,\n-       None,\n-       None,\n-       None,\n-       Some(Set(service))\n-     )\n-\n-  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n-    IO.async { callback =>\n-      cf.handle[Unit] { (result: A, err: Throwable) =>\n-        if (err != null) callback(Left(err))\n-        else callback(Right(result))\n-       \n-      }\n-    }\n-  }\n-  // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n-    val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n-\n-    val json = didDoc.asJson.noSpaces\n-\n-    val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n-    IO.fromCompletableFuture(cf).map(_ => Right(()))\n-\n-    }\n-  \n-  \n"
                },
                {
                    "date": 1697185165462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n-    IO.fromCompletableFuture(cf).map(_ => Right(()))\n+    IO.fromCompletableFuture[](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185170949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n-    IO.fromCompletableFuture[](cf).map(_ => Right(()))\n+    IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185213996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n import com.monovore.decline.effect.*\n import io.circe.parser.*\n import io.circe.syntax.*\n import didcomm.*\n-import io.ipfs.api.{IPFS, MerkleNode}\n+import io.ipfs.api.*\n import java.util.concurrent.CompletableFuture\n \n \n \n"
                },
                {
                    "date": 1697185308858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n+    \n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n     IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n"
                },
                {
                    "date": 1697185317226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    \n+    val ns = new NamedStreamable.ByteArrayWrapper\n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n     IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n"
                },
                {
                    "date": 1697185326084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n-    val ns = new NamedStreamable.ByteArrayWrapper\n+    val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n \n     IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n"
                },
                {
                    "date": 1697185338348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: CompletableFuture[MerkleNode] = ipfs.add(json.getBytes)\n+    val cf: CompletableFuture[MerkleNode] = ipfs.add(ns)\n \n     IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185362544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: CompletableFuture[MerkleNode] = ipfs.add(ns)\n+    val cf = ipfs.add(ns)\n \n     IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185381870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    //IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185398710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    //IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    Either//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185405047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    Either//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    EitherT//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185421743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    EitherT//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    EitherT.rightT(//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185429500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    EitherT.rightT(//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    EitherT.rightT(()//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185435882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf = ipfs.add(ns)\n \n-    EitherT.rightT(()//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n+    EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697185532761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n package xyz.didx\n \n import cats.effect.*\n import cats.syntax.all.*\n+import cats.implicits._\n+\n import com.monovore.decline.*\n import com.monovore.decline.effect.*\n import io.circe.parser.*\n import io.circe.syntax.*\n"
                },
                {
                    "date": 1697185539365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n package xyz.didx\n \n import cats.effect.*\n import cats.syntax.all.*\n-import cats.implicits._\n+import cats.implicits.*\n \n import com.monovore.decline.*\n import com.monovore.decline.effect.*\n import io.circe.parser.*\n"
                },
                {
                    "date": 1697185613465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n import io.circe.syntax.*\n import didcomm.*\n import io.ipfs.api.*\n import java.util.concurrent.CompletableFuture\n+import cats.data.EitherT\n \n \n \n \n"
                },
                {
                    "date": 1697185648498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,15 +38,9 @@\n        Some(Set(service))\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n-    IO.async { callback =>\n-      cf.handle[Unit] { (result: A, err: Throwable) =>\n-        if (err != null) callback(Left(err))\n-        else callback(Right(result))\n-       \n-      }\n-    }\n+   \n   }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n"
                },
                {
                    "date": 1697185664340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n        Some(Set(service))\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n-   \n+    IO.fromCompletableFuture(cf).map(Right(_)).handleErrorWith(e => IO.pure(Left(e)))\n   }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n"
                },
                {
                    "date": 1697185686642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,8 @@\n        Some(Set(service))\n      )\n \n   def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n-    IO.fromCompletableFuture(cf).map(Right(_)).handleErrorWith(e => IO.pure(Left(e)))\n   }\n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n"
                },
                {
                    "date": 1697185703300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = ipfs.add(ns)\n+    val cf = fromipfs.add(ns)\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185711610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromipfs.add(ns)\n+    val cf = fromCompleteableFurureipfs.add(ns)\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185717152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromCompleteableFurureipfs.add(ns)\n+    val cf = fromCompleteableFurure(ipfs.add(ns))\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185750502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromCompleteableFurure(ipfs.add(ns))\n+    val cf = fromCompleteableFurure[(ipfs.add(ns))\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185757013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromCompleteableFurure[(ipfs.add(ns))\n+    val cf = fromCompleteableFurure[MerkleNode](ipfs.add(ns))\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697185771290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromCompleteableFurure[MerkleNode](ipfs.add(ns))\n+    val cf = fromCompletableFuture[MerkleNode](ipfs.add(ns))\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186009203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = fromCompletableFuture[MerkleNode](ipfs.add(ns))\n+    val cf = ipfs.add(ns))\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186025324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = ipfs.add(ns))\n+    val cf: Any = ipfs.add(ns)\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186032493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: Any = ipfs.add(ns)\n+    val cf: List = ipfs.add(ns)\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186049103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: List = ipfs.add(ns)\n+    val cf: List[MerkleNode] = ipfs.add(ns)\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186132647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,14 @@\n import didcomm.*\n import io.ipfs.api.*\n import java.util.concurrent.CompletableFuture\n import cats.data.EitherT\n+import scala.jdk.CollectionConverters._\n \n \n \n \n+\n object DawnCloud:\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n"
                },
                {
                    "date": 1697186151094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: List[MerkleNode] = ipfs.add(ns)\n+    val cf: List[MerkleNode] = ipfs.add(ns).as\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186184372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: List[MerkleNode] = ipfs.add(ns).as\n+    val cf = ipfs.add(ns).asScala.toList\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186191783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf = ipfs.add(ns).asScala.toList\n+    val cf: Any = ipfs.add(ns).asScala.toList\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186203613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: Any = ipfs.add(ns).asScala.toList\n+    val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n \n     EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n"
                },
                {
                    "date": 1697186236935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,10 +39,9 @@\n        None,\n        Some(Set(service))\n      )\n \n-  def fromCompletableFuture[A](cf: CompletableFuture[A]): IO[Either[Error,A]] = {\n-  }\n+  \n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n"
                },
                {
                    "date": 1697186256483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,8 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n \n-    EitherT.rightT(()).value//IO.fromCompletableFuture[MerkleNode](cf).map(_ => Right(()))\n \n     }\n   \n   \n"
                },
                {
                    "date": 1697186276835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,8 +47,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n+    val hash = cf.head.hash.toString\n \n \n     }\n   \n"
                },
                {
                    "date": 1697186285596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,15 +41,16 @@\n      )\n \n   \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,Unit]] = {\n+  def writeIPFS(didDoc: String): IO[Either[Error,String]] = {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.toString\n+    \n \n \n     }\n   \n"
                },
                {
                    "date": 1697186304007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,10 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.toString\n-    \n+    println(s\"IPFS hash: $hash\")\n+    hash\n \n \n     }\n   \n"
                },
                {
                    "date": 1697186321995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n-    hash\n+    hash match\n \n \n     }\n   \n"
                },
                {
                    "date": 1697186327538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,9 @@\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match\n+    \n \n \n     }\n   \n"
                },
                {
                    "date": 1697186340320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,11 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n-    hash match\n+    hash match {\n+      case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n+      case _ => IO.pure(Right(hash))\n     \n \n \n     }\n"
                },
                {
                    "date": 1697186353656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,6 +56,7 @@\n     \n \n \n     }\n+    \n   \n   \n"
                },
                {
                    "date": 1697186359876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,11 +52,8 @@\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n       case _ => IO.pure(Right(hash))\n-    \n+    }\n \n-\n-    }\n-    \n   \n   \n"
                },
                {
                    "date": 1697186368902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,7 +53,7 @@\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n       case _ => IO.pure(Right(hash))\n     }\n-\n   \n   \n+  \n"
                },
                {
                    "date": 1697186517757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n      )\n \n   \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,String]] = {\n+  def writeIPFS(didDoc: String): IO[Either[Error,String]] = \n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n@@ -53,7 +53,8 @@\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n       case _ => IO.pure(Right(hash))\n     }\n+    \n   \n   \n   \n"
                },
                {
                    "date": 1697186535209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,10 +51,10 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash))\n+      case _ => IO.pure(Right(MultiHashhash))\n     }\n-    \n+\n   \n   \n   \n"
                },
                {
                    "date": 1697186545796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(MultiHashhash))\n+      case _ => IO.pure(Right(Multihash.hash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186551971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.hash))\n+      case _ => IO.pure(Right(Multihash.))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186569858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.))\n+      case _ => IO.pure(Right())\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186580217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,60 @@\n+package xyz.didx\n+\n+import cats.effect.*\n+import cats.syntax.all.*\n+import cats.implicits.*\n+\n+import com.monovore.decline.*\n+import com.monovore.decline.effect.*\n+import io.circe.parser.*\n+import io.circe.syntax.*\n+import didcomm.*\n+import io.ipfs.api.*\n+import java.util.concurrent.CompletableFuture\n+import cats.data.EitherT\n+import scala.jdk.CollectionConverters._\n+\n+\n+\n+\n+\n+object DawnCloud:\n+\n+  // create a DIDDoc using DIDCodec\n+  def createDIDDocument(\n+       did: String,\n+       controller: String,\n+       verificationMethod: VerificationMethod,\n+       service: Service\n+   ): DIDDoc =\n+     DIDDoc(\n+       did,\n+       Some(controller),\n+       None,\n+       Some(Set(verificationMethod)),\n+       None,\n+       None,\n+       None,\n+       None,\n+       None,\n+       Some(Set(service))\n+     )\n+\n+  \n+  // write to IPFS\n+  def writeIPFS(didDoc: String): IO[Either[Error,String]] = \n+    val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n+\n+    val json = didDoc.asJson.noSpaces\n+    val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n+    val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n+    val hash = cf.head.hash.toString\n+    println(s\"IPFS hash: $hash\")\n+    hash match {\n+      case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n+      case _ => IO.pure(Right(hash))\n+    }\n+\n+  \n+  \n+  \n"
                },
                {
                    "date": 1697186585669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,70 +51,10 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash))\n+      case _ => IO.pure(Right(hash.))\n     }\n \n   \n   \n   \n-package xyz.didx\n-\n-import cats.effect.*\n-import cats.syntax.all.*\n-import cats.implicits.*\n-\n-import com.monovore.decline.*\n-import com.monovore.decline.effect.*\n-import io.circe.parser.*\n-import io.circe.syntax.*\n-import didcomm.*\n-import io.ipfs.api.*\n-import java.util.concurrent.CompletableFuture\n-import cats.data.EitherT\n-import scala.jdk.CollectionConverters._\n-\n-\n-\n-\n-\n-object DawnCloud:\n-\n-  // create a DIDDoc using DIDCodec\n-  def createDIDDocument(\n-       did: String,\n-       controller: String,\n-       verificationMethod: VerificationMethod,\n-       service: Service\n-   ): DIDDoc =\n-     DIDDoc(\n-       did,\n-       Some(controller),\n-       None,\n-       Some(Set(verificationMethod)),\n-       None,\n-       None,\n-       None,\n-       None,\n-       None,\n-       Some(Set(service))\n-     )\n-\n-  \n-  // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,String]] = \n-    val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n-\n-    val json = didDoc.asJson.noSpaces\n-    val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n-    val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    val hash = cf.head.hash.toString\n-    println(s\"IPFS hash: $hash\")\n-    hash match {\n-      case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right())\n-    }\n-\n-  \n-  \n-  \n"
                },
                {
                    "date": 1697186594419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.))\n+      case _ => IO.pure(Right(hash.m))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186606689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.m))\n+      case _ => IO.pure(Right(hash.to))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186613306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.to))\n+      case _ => IO.pure(Right(hash.toB))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186621748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.toB))\n+      case _ => IO.pure(Right(hash.t))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186627109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.t))\n+      case _ => IO.pure(Right(hash.to))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186633780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.to))\n+      case _ => IO.pure(Right(hash.toBoolean))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186640561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.toBoolean))\n+      case _ => IO.pure(Right(hash.toBase58))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186656491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash.toBase58))\n+      case _ => IO.pure(Right(hash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186662430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(hash))\n+      case _ => IO.pure(Right(Multihashhash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186669879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihashhash))\n+      case _ => IO.pure(Right(Multihash.to(hash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186681642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n import io.ipfs.api.*\n import java.util.concurrent.CompletableFuture\n import cats.data.EitherT\n import scala.jdk.CollectionConverters._\n+import io.ipfs.multihash.Multihash\n \n \n \n \n@@ -51,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.to(hash))\n+      case _ => IO.pure(Right(Multihash.to(hash)))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186690011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.to(hash)))\n+      case _ => IO.pure(Right(Multihash.(hash)))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186696807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.(hash)))\n+      case _ => IO.pure(Right(Multihash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186703591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash))\n+      case _ => IO.pure(Right(Multihash.))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186764452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n      )\n \n   \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,String]] = \n+  def writeIPFS(didDoc: String): IO[Either[Error,StMultihashring]] = \n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n"
                },
                {
                    "date": 1697186770790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n      )\n \n   \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,StMultihashring]] = \n+  def writeIPFS(didDoc: String): IO[Either[Error,StMultihash]] = \n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n"
                },
                {
                    "date": 1697186781522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n      )\n \n   \n   // write to IPFS\n-  def writeIPFS(didDoc: String): IO[Either[Error,StMultihash]] = \n+  def writeIPFS(didDoc: String): IO[Either[Error,Multihash]] = \n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n@@ -52,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash.))\n+      case _ => IO.pure(Right(Multihash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186796763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n     val hash = cf.head.hash.toString\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right(Multihash))\n+      case _ => IO.pure(Right\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186815995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    val hash = cf.head.hash.toString\n+    val hash = cf.head.hash\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n       case _ => IO.pure(Right\n"
                },
                {
                    "date": 1697186828650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    val hash = cf.head.hash\n+    val hash = cf.head.hash.bareMultihash()\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n       case _ => IO.pure(Right\n"
                },
                {
                    "date": 1697186850646,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,10 +51,9 @@\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.bareMultihash()\n     println(s\"IPFS hash: $hash\")\n     hash match {\n-      case \"\" => IO.pure(Left(Error(\"IPFS hash is empty\")))\n-      case _ => IO.pure(Right\n+      \n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186856569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,10 @@\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     val hash = cf.head.hash.bareMultihash()\n     println(s\"IPFS hash: $hash\")\n     hash match {\n-      \n+      case Left(err) => IO(Left(err))\n+      case Right(hash) => IO(Right(hash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186898656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n+    \n     val hash = cf.head.hash.bareMultihash()\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case Left(err) => IO(Left(err))\n"
                },
                {
                    "date": 1697186909507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,9 @@\n import java.util.concurrent.CompletableFuture\n import cats.data.EitherT\n import scala.jdk.CollectionConverters._\n import io.ipfs.multihash.Multihash\n+import scala.util.Try\n \n \n \n \n@@ -48,9 +49,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    \n+    Try\n     val hash = cf.head.hash.bareMultihash()\n     println(s\"IPFS hash: $hash\")\n     hash match {\n       case Left(err) => IO(Left(err))\n"
                },
                {
                    "date": 1697186926647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,14 +49,10 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    Try\n-    val hash = cf.head.hash.bareMultihash()\n-    println(s\"IPFS hash: $hash\")\n-    hash match {\n-      case Left(err) => IO(Left(err))\n-      case Right(hash) => IO(Right(hash))\n+    Try(ipfs.pin.add(cf.head.hash)).toEither\n+  ht(hash) => IO(Right(hash))\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697186939581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,10 +49,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    Try(ipfs.pin.add(cf.head.hash)).toEither\n-  ht(hash) => IO(Right(hash))\n+    IO(Try(ipfs.pin.add(cf.head.hash)).toEither\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187013746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try(ipfs.pin.add(cf.head.hash)).toEither\n+    IO(Tryipfs.pin.add(cf.head.hash)).toEither)\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187022474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,10 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Tryipfs.pin.add(cf.head.hash)).toEither)\n+    IO(Try{ipfs.pin.add(\n+      cf.head.hash)).toEither)\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187032065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try{ipfs.pin.add(\n+    IO(Try{ipfs.pin.add matc\n       cf.head.hash)).toEither)\n     }\n \n   \n"
                },
                {
                    "date": 1697187039485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,11 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try{ipfs.pin.add matc\n+    IO(Try{ipfs.pin.add match\n+      case null => Left(Error(\"IPFS pin failed\"))\n+    \n       cf.head.hash)).toEither)\n     }\n \n   \n"
                },
                {
                    "date": 1697187046132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try{ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n+      case _ => Right(Multihash.fromBase58(\n     \n       cf.head.hash)).toEither)\n     }\n \n"
                },
                {
                    "date": 1697187053443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,8 @@\n     IO(Try{ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n       case _ => Right(Multihash.fromBase58(\n     \n-      cf.head.hash)).toEither)\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187060987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try{ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n-      case _ => Right(Multihash.fromBase58(\n+      case _ => Right(\n     \n     }\n \n   \n"
                },
                {
                    "date": 1697187075983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,11 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try{ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n-      case _ => Right(\n-    \n+      case _ => Right(cf.head.hash)\n     }\n+    }\n \n   \n   \n   \n"
                },
                {
                    "date": 1697187088817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,10 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try{ipfs.pin.add match\n+    IO(Try{\n+      ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n       case _ => Right(cf.head.hash)\n     }\n     }\n"
                },
                {
                    "date": 1697187096422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,10 +53,10 @@\n     IO(Try{\n       ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n       case _ => Right(cf.head.hash)\n+    })\n     }\n-    }\n \n   \n   \n   \n"
                },
                {
                    "date": 1697187110270,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n \n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try{\n+    IO(Try {\n       ipfs.pin.add match\n       case null => Left(Error(\"IPFS pin failed\"))\n       case _ => Right(cf.head.hash)\n     })\n"
                },
                {
                    "date": 1697187138893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,11 +50,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n-      ipfs.pin.add match\n-      case null => Left(Error(\"IPFS pin failed\"))\n-      case _ => Right(cf.head.hash)\n+      ipfs.pin.add \n     })\n     }\n \n   \n"
                },
                {
                    "date": 1697187144085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n       ipfs.pin.add \n-    })\n+    } )\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187153920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,11 @@\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n       ipfs.pin.add \n-    } )\n+    } match\n+      case scala.util.Success(value) => Right(cf.head.hash)\n+    )\n     }\n \n   \n   \n"
                },
                {
                    "date": 1697187164339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,10 +53,11 @@\n     IO(Try {\n       ipfs.pin.add \n     } match\n       case scala.util.Success(value) => Right(cf.head.hash)\n+      case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n     )\n-    }\n+    \n \n   \n   \n   \n"
                },
                {
                    "date": 1697187222306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n-      ipfs.pin.add \n+      ipfs.pin.add ()\n     } match\n       case scala.util.Success(value) => Right(cf.head.hash)\n       case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n     )\n"
                },
                {
                    "date": 1697187230221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n-      ipfs.pin.add ()\n+      ipfs.pin.add (cf.head.hash)\n     } match\n       case scala.util.Success(value) => Right(cf.head.hash)\n       case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n     )\n"
                },
                {
                    "date": 1697187265828,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,8 @@\n   \n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Multihash]] = \n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n-\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n     IO(Try {\n"
                },
                {
                    "date": 1697187914210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    IO(Try {\n+    \n       ipfs.pin.add (cf.head.hash)\n     } match\n       case scala.util.Success(value) => Right(cf.head.hash)\n       case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n"
                },
                {
                    "date": 1697187920704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,9 @@\n \n   \n   // write to IPFS\n   def writeIPFS(didDoc: String): IO[Either[Error,Multihash]] = \n+    IO(Try {\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n"
                },
                {
                    "date": 1697187930886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,8 @@\n     val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n     val json = didDoc.asJson.noSpaces\n     val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n     val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n-    \n       ipfs.pin.add (cf.head.hash)\n     } match\n       case scala.util.Success(value) => Right(cf.head.hash)\n       case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n"
                },
                {
                    "date": 1697188612464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n \n \n \n object DawnCloud:\n+  \n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n        did: String,\n"
                },
                {
                    "date": 1697188642064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n \n \n \n object DawnCloud:\n-  //\n+  // D\n \n   // create a DIDDoc using DIDCodec\n   def createDIDDocument(\n        did: String,\n"
                },
                {
                    "date": 1697189766787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,65 @@\n+package xyz.didx\n+\n+import cats.effect.*\n+import cats.syntax.all.*\n+import cats.implicits.*\n+\n+import com.monovore.decline.*\n+import com.monovore.decline.effect.*\n+import io.circe.parser.*\n+import io.circe.syntax.*\n+import didcomm.*\n+import io.ipfs.api.*\n+import java.util.concurrent.CompletableFuture\n+import cats.data.EitherT\n+import scala.jdk.CollectionConverters._\n+import io.ipfs.multihash.Multihash\n+import scala.util.Try\n+\n+\n+\n+\n+\n+object DawnCloud:\n+  // DawnCloud Registrar and Resolver API  for did:web and did:key methods\n+\n+  // create a DIDDoc using DIDCodec\n+  def createDIDDocument(\n+       did: String,\n+       controller: String,\n+       verificationMethod: VerificationMethod,\n+       service: Service\n+   ): DIDDoc =\n+     DIDDoc(\n+       did,\n+       Some(controller),\n+       None,\n+       Some(Set(verificationMethod)),\n+       None,\n+       None,\n+       None,\n+       None,\n+       None,\n+       Some(Set(service))\n+     )\n+\n+  \n+  // write to IPFS\n+  def writeIPFS(didDoc: String): IO[Either[Error,Multihash]] = \n+    IO(\n+      Try {\n+        val ipfs = new IPFS(\"/ip4/127.0.0.1/tcp/5001\") // Replace with your IPFS HTTP API endpoint URL\n+        val json = didDoc.asJson.noSpaces\n+        val ns = new NamedStreamable.ByteArrayWrapper(json.getBytes)\n+        val cf: List[MerkleNode] = ipfs.add(ns).asScala.toList\n+        ipfs.pin.add (cf.head.hash)\n+         match\n+          case scala.util.Success(value) => Right(cf.head.hash)\n+          case scala.util.Failure(exception) => Left(Error(\"IPFS write error\"))\n+      }\n+    )\n+    \n+\n+  \n+  \n+  \n"
                }
            ],
            "date": 1696858144415,
            "name": "Commit-0",
            "content": "package xyz.didx\n\nimport cats.effect.*\nimport cats.syntax.all.*\nimport com.monovore.decline.*\nimport com.monovore.decline.effect.*\nimport io.circe.*\nimport io.circe.parser.*\nimport io.circe.syntax.*\n\nobject DawnCloud:\n\n  // create a DIDDoc using DIDCodec\n  def makeDIDDoc(did, keyAgreement, authentication, assertion, capabilityDelegation, capabilityInvocation) = \n    DIDDoc(\n      did,\n      keyAgreement,\n      authentication,\n      assertion,\n      capabilityDelegation,\n      capabilityInvocation\n    ).asJson.noSpaces\n  }\n"
        }
    ]
}