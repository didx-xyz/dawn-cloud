{
    "sourceFile": "src/xyz/didx/crypto/Crypto.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 52,
            "patches": [
                {
                    "date": 1698063156106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698063251754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,9 +199,10 @@\n       )\n       jwsObject.sign(new ECDSASigner(privateKey))\n       jwsObject.serialize()\n     } match\n-      case Success(s)         => s.asRight[Error]\n+      case Success(s)         => \n+        s.asRight[Error]\n       case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n"
                },
                {
                    "date": 1698063258499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,8 +200,9 @@\n       jwsObject.sign(new ECDSASigner(privateKey))\n       jwsObject.serialize()\n     } match\n       case Success(s)         => \n+        println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n   }\n \n"
                },
                {
                    "date": 1698063265714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,9 +202,10 @@\n     } match\n       case Success(s)         => \n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n-      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n+      case Failure(exception) => \n+        (exception.getMessage()).asLeft[String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698063843045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -190,9 +190,9 @@\n       case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n   }\n \n //sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n+  def signMessage(message: String, privateKey: ECPrivateKey) = IO {\n     Try {\n       val jwsObject = new JWSObject(\n         new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n         new Payload(message)\n@@ -203,8 +203,9 @@\n       case Success(s)         => \n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n+        println(s\"Error: ${exception.getMessage}\")\n         (exception.getMessage()).asLeft[String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n"
                },
                {
                    "date": 1698063875497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (exception.getMessage()).asLeft[String]\n+        (exception.getMessage()).asLeft[(String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698063881453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (exception.getMessage()).asLeft[(String]\n+        (exception.getMessage()).asLeft[(String,String)]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698064014516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n       val jwsObject = new JWSObject(\n         new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n         new Payload(message)\n       )\n-      jwsObject.sign(new ECDSASigner(privateKey))\n+      val xjwsObject.sign(new ECDSASigner(privateKey))\n       jwsObject.serialize()\n     } match\n       case Success(s)         => \n         println(s\"Signed: ${s}\")\n"
                },
                {
                    "date": 1698064027699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n       val jwsObject = new JWSObject(\n         new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n         new Payload(message)\n       )\n-      val xjwsObject.sign(new ECDSASigner(privateKey))\n+      jwsObject.sign(new ECDSASigner(privateKey))\n       jwsObject.serialize()\n     } match\n       case Success(s)         => \n         println(s\"Signed: ${s}\")\n"
                },
                {
                    "date": 1698064082712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (exception.getMessage()).asLeft[(String,String)]\n+        (exception.getMessage()).asLeft[(String,)]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698064088687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (exception.getMessage()).asLeft[(String,)]\n+        (exception.getMessage()).asLeft[(String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698064140677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (exception.getMessage()).asLeft[(String]\n+        (Errorexception.getMessage()).asLeft[String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698064148328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         println(s\"Signed: ${s}\")\n         s.asRight[Error]\n       case Failure(exception) => \n         println(s\"Error: ${exception.getMessage}\")\n-        (Errorexception.getMessage()).asLeft[String]\n+        (Error(exception.getMessage())).asLeft[String]\n   }\n \n //validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n   def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n"
                },
                {
                    "date": 1698065005627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,8 +309,9 @@\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n+    \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065013874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,9 +309,9 @@\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n-    \n+  def get  \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065020863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,9 +309,9 @@\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n-  def get  \n+  def getECPrivateKey  \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065027387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,9 +309,9 @@\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n-  def getECPrivateKey  \n+  def getECPrivateKey(key)  \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065032924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,9 +309,16 @@\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n-  def getECPrivateKey(key)  \n+  def getECPrivateKey(key: String) =\n+    val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+    val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n+\n+    // Get the elliptic curve parameter specification for the secp160r2 curve\n+    val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n+    IO(keyFactory.generatePrivate(privateKeySpec).asRight[Exception])  \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065919509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,8 +317,9 @@\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n     IO(keyFactory.generatePrivate(privateKeySpec).asRight[Exception])  \n+    \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698065956942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -190,9 +190,9 @@\n       case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n   }\n \n //sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: ECPrivateKey) = IO {\n+  def signMessage(message: String, privateKey: PrivateKey) = IO {\n     Try {\n       val jwsObject = new JWSObject(\n         new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n         new Payload(message)\n@@ -317,9 +317,9 @@\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n     IO(keyFactory.generatePrivate(privateKeySpec).asRight[Exception])  \n-    \n+\n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n     nonce: Array[Byte]\n"
                },
                {
                    "date": 1698066990062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -190,9 +190,9 @@\n       case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n   }\n \n //sign message using nimbus-jose-jwt library and return the signed message as base64 string\n-  def signMessage(message: String, privateKey: PrivateKey) = IO {\n+  def signMessage(message: String, privateKey: ECPrivateKey) = IO {\n     Try {\n       val jwsObject = new JWSObject(\n         new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n         new Payload(message)\n"
                },
                {
                    "date": 1698067110375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n+   // val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n"
                },
                {
                    "date": 1698067153008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-   // val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n+    val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n"
                },
                {
                    "date": 1698067760282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -310,10 +310,9 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-    val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPrivateKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(privateKeyParams)\n+   val keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n"
                },
                {
                    "date": 1698067770669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -310,9 +310,9 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-   val keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)\n+   val keySpec = new PKCS8EncodedKeySpec(key)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n"
                },
                {
                    "date": 1698067785582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,9 @@\n import java.security.spec.ECPublicKeySpec\n import java.security.spec.ECGenParameterSpec\n import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\n import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory\n+import java.security.spec.PKCS8EncodedKeySpec\n \n \n \n object Crypto:\n"
                },
                {
                    "date": 1698067844756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,8 @@\n    val keySpec = new PKCS8EncodedKeySpec(key)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n     IO(keyFactory.generatePrivate(privateKeySpec).asRight[Exception])  \n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1698067875977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n    val keySpec = new PKCS8EncodedKeySpec(key)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    IO(keyFactory.generatePrivate(privateKeySpec).asRight[Exception])  \n+    IO(keyFactory.generatePrivate(eySpec).asRight[Exception])  \n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1698067903337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,13 +311,13 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-   val keySpec = new PKCS8EncodedKeySpec(key)\n+   val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n-    IO(keyFactory.generatePrivate(eySpec).asRight[Exception])  \n+    IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n     myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n"
                },
                {
                    "date": 1698067915786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-   val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n+    val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698068285615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-\n+   \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n \n"
                },
                {
                    "date": 1698068409757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,8 +311,10 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n+    val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n    \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n"
                },
                {
                    "date": 1698068420095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-    val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+    val publicKeyParams = new Ed25519PKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n \n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n    \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068443325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-    val publicKeyParams = new Ed25519PKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+    val pKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n \n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n    \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068516481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,12 +311,13 @@\n     val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n-    val pKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n+    val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n \n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-   \n+   val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+\n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n \n"
                },
                {
                    "date": 1698068522880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -314,9 +314,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n \n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-   val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+    val pKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698068530331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -314,9 +314,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n \n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val pKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+    val priteKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698068677557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,11 +312,11 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-\n+val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val priteKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698068687162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n+    val subjectPublicKeyInfo = SubjectPKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068695257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPublicKeyInfo = SubjectPKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n+    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068726093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n+    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPKeyInfo(publicKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068732925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPKeyInfo(publicKeyParams)\n+    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPrivateKeyInfo(pKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698068908655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPublicKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPrivateKeyInfo(pKeyParams)\n+    val subjectPKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698069263162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPKeyInfo = SubjectPrivateKeyInfoFactory.createSubjectPrivateKeyInfo(privateKeyParams)\n+    val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createSubjectPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698069282147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n import java.security.spec.ECGenParameterSpec\n import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\n import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory\n import java.security.spec.PKCS8EncodedKeySpec\n+import org.bouncycastle.crypto.util.PrivateKeyInfoFactory\n \n \n \n object Crypto:\n"
                },
                {
                    "date": 1698069340405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,9 +313,9 @@\n     IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n \n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n-    val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createSubjectPrivateKeyInfo(privateKeyParams)\n+    val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n"
                },
                {
                    "date": 1698069387261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698069863088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698069887461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo)\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698069895861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.)\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698069932419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privateKeyParams = new Ed25519PrivateKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n     val subjectPrivateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(privateKeyParams)\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n-    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded())\n+    val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n"
                },
                {
                    "date": 1698070561990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -318,9 +318,9 @@\n     val keySpec = new PKCS8EncodedKeySpec(Base64.getUrlDecoder().decode(key))\n     val privateKeySpec = new X509EncodedKeySpec(subjectPrivateKeyInfo.getEncoded)\n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n-    val keyFactory = KeyFactory.getInstance(\"Ed25519\",\")\n+    val keyFactory = KeyFactory.getInstance(\"Ed25519\"\")\n     IO(keyFactory.generatePrivate(keySpec).asRight[Exception])  \n \n   def computeSharedSecret(\n     peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n"
                },
                {
                    "date": 1698071317082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,9 +315,9 @@\n   def getECPrivateKey(key: String) =\n     val privKeyInfo = new PrivateKeyInfo(new AlgorithmIdentifier(EdECObjectIdentifiers.id_Ed25519), new DEROctetString(privateKeyBytes));\n     val pkcs8KeySpec = new PKCS8EncodedKeySpec(privKeyInfo.getEncoded());\n \n-    jcaPrivateKey = keyFactory.generatePrivate(pkcs8KeySpec);\n+    val jcaPrivateKey = keyFactory.generatePrivate(pkcs8KeySpec);\n \n \n     // Get the elliptic curve parameter specification for the secp160r2 curve\n     val keyFactory = KeyFactory.getInstance(\"Ed25519\")\n"
                }
            ],
            "date": 1698063156106,
            "name": "Commit-0",
            "content": "package xyz.didx\n\nimport java.security.KeyStore\nimport java.security.KeyPair\nimport java.security.KeyPairGenerator\nimport java.security.Key\n\nimport cats.implicits._\nimport cats.effect.IO\n\nimport java.security.KeyFactory\nimport java.security.spec.X509EncodedKeySpec\nimport java.security.KeyStore.TrustedCertificateEntry\nimport java.util.Base64\nimport java.security.PublicKey\nimport com.nimbusds.jose.*\nimport com.nimbusds.jose.crypto.*\nimport com.nimbusds.jose.jwk.*\nimport com.nimbusds.jose.jwk.gen.*\nimport com.nimbusds.jose.jwk.JWKSet\nimport java.nio.file.Paths\nimport java.io.FileOutputStream\nimport java.io.FileInputStream\nimport java.security.Security\nimport org.bouncycastle.jce.provider.BouncyCastleProvider\nimport java.security.cert.X509Certificate\nimport org.bouncycastle.asn1.x500.X500Name\nimport org.bouncycastle.operator.jcajce.JcaContentSignerBuilder\nimport org.bouncycastle.cert.X509v3CertificateBuilder\nimport org.bouncycastle.cert.jcajce.JcaX509CertificateConverter\nimport java.math.BigInteger\nimport java.util.Date\nimport java.security.interfaces.ECPrivateKey\nimport java.security.interfaces.ECPublicKey\nimport scala.util.Try\nimport scala.util.{Success, Failure}\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator\nimport java.security.PrivateKey\nimport org.bouncycastle.crypto.digests.SHA256Digest\nimport org.bouncycastle.crypto.params.KDFParameters\nimport org.bouncycastle.jce.ECNamedCurveTable\nimport org.bouncycastle.crypto.params.ECPrivateKeyParameters\nimport org.bouncycastle.crypto.params.ECDomainParameters\nimport org.bouncycastle.math.ec.ECPoint\nimport javax.crypto.Cipher\nimport javax.crypto.spec.SecretKeySpec\nimport javax.crypto.spec.GCMParameterSpec\nimport java.util.Base64\nimport org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters\nimport scala.annotation.tailrec\nimport org.bouncycastle.jce.spec.ECNamedCurveSpec\nimport org.bouncycastle.jce.ECPointUtil\nimport java.security.spec.ECPublicKeySpec\nimport java.security.spec.ECGenParameterSpec\nimport org.bouncycastle.crypto.params.Ed25519PublicKeyParameters\nimport org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory\n\n\n\nobject Crypto:\n  val AES_GCM_NOPADDING = \"AES/GCM/NoPadding\"\n  val IV_SIZE           = 12  // bytes\n  val TAG_SIZE          = 128 // bits\n\n  Security.addProvider(new BouncyCastleProvider())\n  // if the keystore file does not exist, create a new keystore file\n \n  // create a java keystore object\n\n  def createKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n    val keyStore = KeyStore.getInstance(\"JKS\")\n    Try {\n      keyStore.load(null, password.toCharArray)\n      val keystoreFile         = Paths.get(keystorePath).toFile\n      val keystoreOutputStream = new FileOutputStream(keystoreFile)\n      keyStore.store(keystoreOutputStream, password.toCharArray)\n      keystoreOutputStream.close()\n    } match\n      case Success(_)         => keyStore.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n  }\n\n  def loadKeyStore(password: String, keystorePath: String): IO[Either[Error, KeyStore]] = IO {\n    val keyStore = KeyStore.getInstance(\"JKS\")\n    Try {\n      val keystoreFile        = Paths.get(keystorePath).toFile\n      val keystoreInputStream = new FileInputStream(keystoreFile)\n      keyStore.load(keystoreInputStream, password.toCharArray)\n      keystoreInputStream.close()\n    } match\n      case Success(_)         => keyStore.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyStore]\n  }\n\n  // create a RSA key pair using java.security.KeyPairGenerator\n  def createRSAKeyPair(): IO[Either[Error, KeyPair]] = IO {\n    val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n    keyPairGenerator.initialize(2048)\n    Try {\n      keyPairGenerator.generateKeyPair()\n    } match\n      case Success(keyPair)   => keyPair.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n  }\n\n  def createEd25519KeyPair(alias:String): IO[Either[Error, KeyPair]] = IO {\n      val keyPairGenerator = KeyPairGenerator.getInstance(\"Ed25519\", \"BC\")\n      Try {\n        keyPairGenerator.generateKeyPair()\n      } match\n        case Success(keyPair)   => keyPair.asRight[Error]\n        case Failure(exception) => Error(exception.getMessage()).asLeft[KeyPair]\n\n    }\n\n\n  // create a ED525519 key pair using net.i2p.crypto.eddsa.EdDSASecurityProvider\n  def createKeyPair(alias: String): IO[Either[Error, OctetKeyPair]] =\n    for {\n      // keyStore <- getKeyStore(\"password\", keystorePath)\n      jwk <- Try {\n               new OctetKeyPairGenerator(Curve.Ed25519)\n                 .keyID(alias)\n                 .generate()\n\n             } match\n               case Success(jwk)       => IO(jwk.asRight[Error])\n               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[OctetKeyPair])\n\n    } yield jwk\n\n  // create a EC P-384 key pair\n  def createKeyPairECP384(alias: String): IO[Either[Error, ECKey]] =\n    for {\n      // keyStore <- getKeyStore(\"password\", keystorePath)\n      jwk <- Try {\n               new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n\n               // new ECKeyGenerator(Curve.P_384).keyID(alias).generate()\n             } match\n               case Success(jwk)       => IO(jwk.asRight[Error])\n               case Failure(exception) => IO(Error(exception.getMessage()).asLeft[ECKey])\n\n    } yield jwk // .computeThumbprint().toString()\n\n  // save the JWKSet to a file\n  \n\n  // store the private key keystore\n \n\n \n\n  // get the private key from keystore\n  def getPrivateKey(keyStore: KeyStore, alias: String, password: String): IO[Either[Error, Key]] = IO {\n    Try {\n      keyStore.getKey(alias, password.toCharArray())\n    } match\n      case Success(key)       => key.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[Key]\n  }\n\n  // encrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n  def decryptMessage(encryptedMessage: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n\n    Try {\n      val jweObject = JWEObject.parse(encryptedMessage)\n      jweObject.decrypt(new ECDHDecrypter(privateKey))\n      jweObject.getPayload().toString()\n    } match\n      case Success(message)   => message.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n\n  }\n\n  def encryptMessage(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n    Try {\n      val o = new JWEObject(\n        new JWEHeader.Builder(JWEAlgorithm.ECDH_ES_A256KW, com.nimbusds.jose.EncryptionMethod.A256GCM)\n          .keyID(publicKey.toString())\n          .build(),\n        new Payload(message)\n      )\n      o.encrypt(new ECDHEncrypter(publicKey))\n      o.serialize()\n    } match\n      case Success(s)         => s.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n  }\n\n//sign message using nimbus-jose-jwt library and return the signed message as base64 string\n  def signMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n    Try {\n      val jwsObject = new JWSObject(\n        new JWSHeader.Builder(JWSAlgorithm.EdDSA).keyID(privateKey.toString()).build(),\n        new Payload(message)\n      )\n      jwsObject.sign(new ECDSASigner(privateKey))\n      jwsObject.serialize()\n    } match\n      case Success(s)         => s.asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n  }\n\n//validate the signature of the message using nimbus-jose-jwt library and return the boolean value\n  def validateSignature(message: String, publicKey: ECPublicKey): IO[Either[Error, String]] = IO {\n    val jwsObject = JWSObject.parse(message)\n    Try(jwsObject.verify(new ECDSAVerifier(publicKey))) match\n      case Success(_)         => jwsObject.getPayload().toString().asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n  }\n\n  // decrypt the message using nimbus-jose-jwt library and return the encrypted message as base64 string\n  /*  def decryptMessage(message: String, privateKey: ECPrivateKey): IO[Either[Error, String]] = IO {\n    val jweObject = JWEObject.parse(message)\n    Try(jweObject.decrypt(new ECDHDecrypter(privateKey))) match\n      case Success(_)         => jweObject.getPayload().toString().asRight[Error]\n      case Failure(exception) => Error(exception.getMessage()).asLeft[String]\n  } */\n\n  // derive symmetric key using nimbus-jose-jwt library and return the key as base64 string\n\n  def createSelfSignedCertificate(alias: String): IO[Either[Error, X509Certificate]] = IO {\n    Try {\n      Security.addProvider(new BouncyCastleProvider())\n      val keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\")\n      keyPairGenerator.initialize(2048)\n      val keyPair          = keyPairGenerator.generateKeyPair()\n      val subject          = new X500Name(s\"CN=$alias\")\n      val issuer           = subject\n      val serialNumber     = BigInteger.valueOf(System.currentTimeMillis())\n      val notBefore        = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000) // 1 day ago\n      val notAfter         =\n        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000) // 1 year from now\n      val pubKey        =\n        org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded)\n      val publicKeyInfo = org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(pubKey)\n      val certBuilder   = new X509v3CertificateBuilder(\n        issuer,\n        serialNumber,\n        notBefore,\n        notAfter,\n        subject,\n        publicKeyInfo\n      )\n      val contentSigner = JcaContentSignerBuilder(\"SHA256WithRSA\").build(keyPair.getPrivate())\n      val certHolder    = certBuilder.build(contentSigner)\n      val certConverter = JcaX509CertificateConverter()\n      certConverter.getCertificate(certHolder)\n    } match\n      case Success(certificate) => certificate.asRight[Error]\n      case Failure(exception)   => Error(exception.getMessage()).asLeft[X509Certificate]\n  }\n\n  def storeCertificate(\n    keyStore: KeyStore,\n    certificate: X509Certificate,\n    alias: String,\n    password: Array[Char]\n  ): IO[Either[Error, Unit]] =\n    IO {\n      Try {\n        keyStore.setCertificateEntry(alias, certificate)\n      } match\n        case Success(_)         => ().asRight[Error]\n        case Failure(exception) => Error(exception.getMessage()).asLeft[Unit]\n    }\n    // Save the keystore to a file or perform any other necessary operations\n\n  def getPublicKeyFromBase64(base64String: String): IO[Either[Exception, PublicKey]] =\n    val keyBytes   = Base64.getDecoder.decode(base64String)\n    val keySpec    = new X509EncodedKeySpec(keyBytes)\n    val keyFactory = KeyFactory.getInstance(\"EdDSA\")\n    IO(keyFactory.generatePublic(keySpec).asRight[Exception])\n\n  def getECPublicKeyFromBase58(base58String: String): IO[Either[Exception, ECPublicKey]] =\n    // Get the elliptic curve parameter specification for the secp160r2 curve\n    val ecParameterSpec = ECNamedCurveTable.getParameterSpec(\"curve25519\")\n    // Create a new ECNamedCurveSpec\n    val  params = new ECNamedCurveSpec(\"curve25519\", ecParameterSpec.getCurve(), ecParameterSpec.getG(), ecParameterSpec.getN())\n    // Decode the base58 string into a byte array\n\n    val keyBytes   = Crypto.decodeFromBase58(base58String)\n    val decodedBytes: Array[Byte] = keyBytes\n\n    // Decode the public point from the base58 string\n    val  publicPoint =  ECPointUtil.decodePoint(params.getCurve(), decodedBytes)\n    // Create the public key specification from the public point and the named curve specification\n    val pubKeySpec = new ECPublicKeySpec(publicPoint, params)\n    // Create the key specification from the byte array\n   // val keySpec    = new X509EncodedKeySpec(keyBytes)\n    // Create the key factory for the EC algorithm\n    val keyFactory = KeyFactory.getInstance(\"EC\")\n    // Generate the public key\n    IO(keyFactory.generatePublic(pubKeySpec).asInstanceOf[ECPublicKey].asRight[Exception])\n\n\n  def getECPublicKey(key: String) =\n    val publicKeyParams = new Ed25519PublicKeyParameters(Base64.getUrlDecoder().decode(key), 0)\n    val subjectPublicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(publicKeyParams)\n\n    // Get the elliptic curve parameter specification for the secp160r2 curve\n    val keyFactory = KeyFactory.getInstance(\"Ed25519\", \"BC\")\n    val publicKeySpec = new X509EncodedKeySpec(subjectPublicKeyInfo.getEncoded())\n    IO(keyFactory.generatePublic(publicKeySpec).asRight[Exception])\n\n  def computeSharedSecret(\n    peerPublicKey: org.bouncycastle.jce.interfaces.ECPublicKey,\n    myPrivateKey: org.bouncycastle.jce.interfaces.ECPrivateKey,\n    nonce: Array[Byte]\n  ): IO[Either[Error, Array[Byte]]] =\n    IO {\n      Try {\n        val agreement        = new ECDHBasicAgreement()\n        val curveParams      = ECNamedCurveTable.getParameterSpec(\"secp256r1\")\n        val domainParams     =\n          new ECDomainParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH())\n        val privateKeyParams = new ECPrivateKeyParameters(myPrivateKey.getD(), domainParams)\n        agreement.init(privateKeyParams)\n\n        val pubKeyParams       = new ECPublicKeyParameters(peerPublicKey.getQ(), domainParams)\n        val sharedSecretBigInt = agreement.calculateAgreement(pubKeyParams)\n\n        // Convert shared secret to bytes\n        val sharedSecretBytes = sharedSecretBigInt.toByteArray\n\n        // Derive AES key using KDF (with nonce/salt)\n        val kdf = new KDF2BytesGenerator(new SHA256Digest())\n        kdf.init(new KDFParameters(sharedSecretBytes, nonce))\n\n        val aesKey = new Array[Byte](32) // For AES-256\n        kdf.generateBytes(aesKey, 0, aesKey.length)\n        aesKey\n      } match\n        case Success(s)         => s.asRight[Error]\n        case Failure(exception) => Error(exception.getMessage()).asLeft[Array[Byte]]\n    }\n\n  def encrypt(key: Array[Byte], plaintext: String): IO[Either[Error, (String, String)]] = IO {\n    Try {\n      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n      val iv     = new Array[Byte](IV_SIZE)\n      new java.security.SecureRandom().nextBytes(iv)\n      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n\n      val ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"))\n      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n    } match {\n      case Success(value)     => Right(value)\n      case Failure(exception) => Left(Error(exception.getMessage))\n    }\n  }\n\n  def encrypt(key: java.security.PublicKey, text:String): IO[Either[Error, (String, String)]] = IO {\n    Try {\n      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n      val iv     = new Array[Byte](IV_SIZE)\n      new java.security.SecureRandom().nextBytes(iv)\n      val spec   = new GCMParameterSpec(TAG_SIZE, iv)\n      cipher.init(Cipher.ENCRYPT_MODE, key, spec)\n\n      val ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"))\n      (Base64.getEncoder.encodeToString(ciphertext), Base64.getEncoder.encodeToString(iv))\n    } match {\n      case Success(value)     => \n        println(s\"Encrypted: ${value}\")\n        Right(value)\n      case Failure(exception) => \n        println(s\"Error: ${exception.getMessage}\")\n        Left(Error(exception.getMessage))\n    }\n  }\n\n  def decrypt(key: Array[Byte], ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n    Try {\n      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), spec)\n\n      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n      new String(decrypted, \"UTF-8\")\n    } match {\n      case Success(value)     => Right(value)\n      case Failure(exception) => Left(Error(exception.getMessage))\n    }\n  }\n\n  def decrypt(key: java.security.PrivateKey, ciphertext: String, ivStr: String): IO[Either[Error, String]] = IO {\n    Try {\n      val cipher = Cipher.getInstance(AES_GCM_NOPADDING)\n      val spec   = new GCMParameterSpec(TAG_SIZE, Base64.getDecoder.decode(ivStr))\n      cipher.init(Cipher.DECRYPT_MODE, key, spec)\n\n      val decrypted = cipher.doFinal(Base64.getDecoder.decode(ciphertext))\n      new String(decrypted, \"UTF-8\")\n    } match {\n      case Success(value)     => Right(value)\n      case Failure(exception) => Left(Error(exception.getMessage))\n    }\n  }\n\n  def makeDidKey(kty: String, crv: String, pubKey: PublicKey): Option[String] =\n     val algo = xyz.didx.Algorithm(kty, crv)\n     val key: Option[String] = pubKey.getEncoded() match\n       case b: Array[Byte] => Some(encodeToBase58(b))\n       case null           => None\n     (algo, key) match\n       case (a, Some(k)) => Some(s\"did:key:${a}$k\")\n       case _            => None\n\n  val alphabetBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\n  val idxToChar = Map(alphabetBase58.zipWithIndex.map(_.swap): _*)\n\n  val charToIdx = Map(alphabetBase58.zipWithIndex: _*)\n\n  def encodeToBase58(array: Array[Byte]): String =\n    (LazyList.fill(array.takeWhile(_ == 0).length)(1.toByte) ++ LazyList\n      .unfold(\n        BigInt(0.toByte +: array)\n      )(n => if (n == 0) None else Some((n /% 58).swap))\n      .map(_.toInt)\n      .reverse\n      .map(x => idxToChar(x))).mkString\n\n  def decodeFromBase58(b58: String): Array[Byte] = {\n    val zeroCount = b58.takeWhile(_ == '1').length\n    Array.fill(zeroCount)(0.toByte) ++\n      b58\n        .drop(zeroCount)\n        .map(charToIdx)\n        .toList\n        .foldLeft(BigInt(0))((acc, x) => acc * 58 + x)\n        .toByteArray\n        .dropWhile(_ == 0.toByte)\n  }\n  def encodeB58(input: Seq[Byte]): String = {\n     if (input.isEmpty) \"\"\n     else {\n       val big = new BigInteger(1, input.toArray)\n       val builder = new StringBuilder\n\n       @tailrec\n       def encode1(current: BigInteger): Unit = current match {\n         case BigInteger.ZERO => ()\n         case _ =>\n           val Array(x, remainder) = current.divideAndRemainder(BigInteger.valueOf(58L))\n           builder.append(alphabetBase58.charAt(remainder.intValue))\n           encode1(x)\n       }\n       encode1(big)\n       input.takeWhile(_ == 0).map(_ => builder.append(alphabetBase58.charAt(0)))\n       builder.toString().reverse\n     }\n   }"
        }
    ]
}